{"version":3,"sources":["../../../../node_modules/tslib/tslib.es6.js","../../../packages/core/esm5/testing/src/async_fallback.js","../../../packages/core/esm5/testing/src/component_fixture.js","../../../packages/core/esm5/testing/src/fake_async_fallback.js","../../../packages/core/esm5/testing/src/fake_async.js","../../../packages/core/esm5/testing/src/async_test_completer.js","../../../packages/core/esm5/testing/src/test_compiler.js","../../../packages/core/esm5/testing/src/test_bed.js","../../../packages/core/esm5/testing/src/before_each.js","../../../packages/core/esm5/testing/src/render3.js","../../../packages/core/esm5/testing/src/async.js"],"names":["exports","module","factory","require","extendStatics","Object","setPrototypeOf","__proto__","Array","d","b","p","hasOwnProperty","fn","context","finishCallback","failCallback","currentZone","Zone","current","AsyncTestZoneSpec","undefined","Error","ProxyZoneSpec","proxyZoneSpec","get","assertPresent","getZoneWith","getDelegate","run","testZoneSpec","error","setDelegate","previousDelegate","ComponentFixture","componentRef","ngZone","_autoDetect","_this","this","_isStable","_isDestroyed","_resolve","_promise","_onUnstableSubscription","_onStableSubscription","getDebugNode","_onMicrotaskEmptySubscription","_onErrorSubscription","changeDetectorRef","elementRef","location","debugElement","_angular_core","nativeElement","detectChanges","hasPendingMacrotasks","onError","subscribe","next","prototype","_tick","checkNoChanges","autoDetectChanges","autoDetect","isStable","Promise","resolve","res","_getRenderer","whenRenderingDone","renderer","destroy","unsubscribe","resetFakeAsyncZoneFallback","_getFakeAsyncZoneSpec","flushMicrotasksFallback","resetFakeAsyncZone","fakeAsyncTestModule","AsyncTestCompleter","rej","_reject","done","value","fail","stackTrace","defineProperty","TestingCompiler","_super","apply","arguments","unimplemented","enumerable","configurable","overrideModule","overrides","overrideDirective","directive","overrideComponent","component","getComponentFactory","getComponentFromError","decorators","Compiler","Injectable","TestComponentRenderer","TestBed","_instantiated","_compiler","_moduleRef","_moduleFactory","_compilerOptions","_moduleOverrides","_componentOverrides","_directiveOverrides","_pipeOverrides","_providers","_declarations","_imports","_schemas","_activeFixtures","_testEnvAotSummaries","_aotSummaries","_templateOverrides","resetTestEnvironment","configureCompiler","configureTestingModule","compileComponents","getTestBed","ngModule","override","overridePipe","pipe","template","overrideTemplateUsingTestingModule","overrideProvider","token","provider","deprecatedOverrideProvider","Injector","notFoundValue","THROW_IF_NOT_FOUND","platform","aotSummaries","resetTestingModule","clearOverrides","ɵclearOverrides","_isRoot","_rootProviderOverrides","forEach","fixture","e","console","componentInstance","stacktrace","config","_assertNotInstantiated","push","moduleDef","_a","_b","_c","_d","providers","declarations","imports","schemas","moduleType","_createCompilerAndModule","compileModuleAndAllComponentsAsync","then","moduleAndComponentFactories","ngModuleFactory","_initIfNeeded","compileModuleAndAllComponentsSync","stringify","errorCompType","ɵstringify","_i","NgZone","length","templateOf","compFactory","ɵoverrideComponentView","enableLongStackTrace","provide","useValue","ngZoneInjector","create","ApplicationInitStatus","injector","runInitializers","concat","map","entry","type","NgModule","args","rootProviderOverrides","slice","RootScopeModule","ctorParameters","APP_ROOT","rootScopeImports","ɵAPP_ROOT","DynamicTestModule","compilerFactory","TestingCompilerFactory","createTestingCompiler","summary","loadAotSummaries","methodName","methodDescription","result","UNDEFINED","execute","tokens","params","t","overrideProviderImpl","deprecated","ngInjectableDef","providedIn","useFactory","deps","flags","Optional","dep","SkipSelf","depFlags","depToken","ɵoverrideProvider","deprecatedBehavior","Component","OverrideComponent","selector","createComponent","componentFactory","noNgZone","ComponentFixtureNoNgZone","ComponentFixtureAutoDetect","testComponentRenderer","rootElId","_nextRootElementId","insertRootElement","initComponent","NULL","_testBed","testBed","completer","InjectSetupWrapper","_moduleDef","_addModule","inject","self","call","window","global","_global$1","beforeEach","savedDocument","domino","ensureDocument","Event","Node","impl","savedRequestAnimationFrame","requestAnimationFrame","cb","cleanupDocument","document","savedNode","_Zone","reject","asyncTest","err","runInTestZone","fakeAsync","_inFakeAsyncCall","_fakeAsyncTestZoneSpec","FakeAsyncTestZoneSpec","lastProxyZoneSpec","pendingPeriodicTimers","pendingTimers","millis","tick","maxTurns","flush","discardPeriodicTasks","flushMicrotasks","html","blockFn","body","innerHTML","blockReturn"],"mappings":"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","file":"/Users/martin/workspace/angular/dist/packages-dist/core/bundles/core-testing.umd.min.js.map","sourcesContent":["/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = Object.setPrototypeOf ||\r\n    ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n    function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = Object.assign || function __assign(t) {\r\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n        s = arguments[i];\r\n        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n    }\r\n    return t;\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)\r\n            t[p[i]] = s[p[i]];\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = y[op[0] & 2 ? \"return\" : op[0] ? \"throw\" : \"next\"]) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [0, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport function __exportStar(m, exports) {\r\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\n\r\nexport function __values(o) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator], i = 0;\r\n    if (m) return m.call(o);\r\n    return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);  }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { if (o[n]) i[n] = function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; }; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator];\r\n    return m ? m.call(o) : typeof __values === \"function\" ? __values(o) : o[Symbol.iterator]();\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result.default = mod;\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar _global = (typeof window === 'undefined' ? global : window);\n/**\n * Wraps a test function in an asynchronous test zone. The test will automatically\n * complete when all asynchronous calls within this zone are done. Can be used\n * to wrap an {@link inject} call.\n *\n * Example:\n *\n * ```\n * it('...', async(inject([AClass], (object) => {\n *   object.doSomething.then(() => {\n *     expect(...);\n *   })\n * });\n * ```\n *\n *\n */\nexport function asyncFallback(fn) {\n    // If we're running using the Jasmine test framework, adapt to call the 'done'\n    // function when asynchronous activity is finished.\n    if (_global.jasmine) {\n        // Not using an arrow function to preserve context passed from call site\n        return function (done) {\n            if (!done) {\n                // if we run beforeEach in @angular/core/testing/testing_internal then we get no done\n                // fake it here and assume sync.\n                done = function () { };\n                done.fail = function (e) { throw e; };\n            }\n            runInTestZone(fn, this, done, function (err) {\n                if (typeof err === 'string') {\n                    return done.fail(new Error(err));\n                }\n                else {\n                    done.fail(err);\n                }\n            });\n        };\n    }\n    // Otherwise, return a promise which will resolve when asynchronous activity\n    // is finished. This will be correctly consumed by the Mocha framework with\n    // it('...', async(myFn)); or can be used in a custom framework.\n    // Not using an arrow function to preserve context passed from call site\n    return function () {\n        var _this = this;\n        return new Promise(function (finishCallback, failCallback) {\n            runInTestZone(fn, _this, finishCallback, failCallback);\n        });\n    };\n}\nfunction runInTestZone(fn, context, finishCallback, failCallback) {\n    var currentZone = Zone.current;\n    var AsyncTestZoneSpec = Zone['AsyncTestZoneSpec'];\n    if (AsyncTestZoneSpec === undefined) {\n        throw new Error('AsyncTestZoneSpec is needed for the async() test helper but could not be found. ' +\n            'Please make sure that your environment includes zone.js/dist/async-test.js');\n    }\n    var ProxyZoneSpec = Zone['ProxyZoneSpec'];\n    if (ProxyZoneSpec === undefined) {\n        throw new Error('ProxyZoneSpec is needed for the async() test helper but could not be found. ' +\n            'Please make sure that your environment includes zone.js/dist/proxy.js');\n    }\n    var proxyZoneSpec = ProxyZoneSpec.get();\n    ProxyZoneSpec.assertPresent();\n    // We need to create the AsyncTestZoneSpec outside the ProxyZone.\n    // If we do it in ProxyZone then we will get to infinite recursion.\n    var proxyZone = Zone.current.getZoneWith('ProxyZoneSpec');\n    var previousDelegate = proxyZoneSpec.getDelegate();\n    proxyZone.parent.run(function () {\n        var testZoneSpec = new AsyncTestZoneSpec(function () {\n            // Need to restore the original zone.\n            currentZone.run(function () {\n                if (proxyZoneSpec.getDelegate() == testZoneSpec) {\n                    // Only reset the zone spec if it's sill this one. Otherwise, assume it's OK.\n                    proxyZoneSpec.setDelegate(previousDelegate);\n                }\n                finishCallback();\n            });\n        }, function (error) {\n            // Need to restore the original zone.\n            currentZone.run(function () {\n                if (proxyZoneSpec.getDelegate() == testZoneSpec) {\n                    // Only reset the zone spec if it's sill this one. Otherwise, assume it's OK.\n                    proxyZoneSpec.setDelegate(previousDelegate);\n                }\n                failCallback(error);\n            });\n        }, 'test');\n        proxyZoneSpec.setDelegate(testZoneSpec);\n    });\n    return Zone.current.runGuarded(fn, context);\n}\n//# sourceMappingURL=async_fallback.js.map","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { RendererFactory2, getDebugNode } from '@angular/core';\n/**\n * Fixture for debugging and testing a component.\n *\n *\n */\nvar /**\n * Fixture for debugging and testing a component.\n *\n *\n */\nComponentFixture = /** @class */ (function () {\n    function ComponentFixture(componentRef, ngZone, _autoDetect) {\n        var _this = this;\n        this.componentRef = componentRef;\n        this.ngZone = ngZone;\n        this._autoDetect = _autoDetect;\n        this._isStable = true;\n        this._isDestroyed = false;\n        this._resolve = null;\n        this._promise = null;\n        this._onUnstableSubscription = null;\n        this._onStableSubscription = null;\n        this._onMicrotaskEmptySubscription = null;\n        this._onErrorSubscription = null;\n        this.changeDetectorRef = componentRef.changeDetectorRef;\n        this.elementRef = componentRef.location;\n        this.debugElement = getDebugNode(this.elementRef.nativeElement);\n        this.componentInstance = componentRef.instance;\n        this.nativeElement = this.elementRef.nativeElement;\n        this.componentRef = componentRef;\n        this.ngZone = ngZone;\n        if (ngZone) {\n            // Create subscriptions outside the NgZone so that the callbacks run oustide\n            // of NgZone.\n            ngZone.runOutsideAngular(function () {\n                _this._onUnstableSubscription =\n                    ngZone.onUnstable.subscribe({ next: function () { _this._isStable = false; } });\n                _this._onMicrotaskEmptySubscription = ngZone.onMicrotaskEmpty.subscribe({\n                    next: function () {\n                        if (_this._autoDetect) {\n                            // Do a change detection run with checkNoChanges set to true to check\n                            // there are no changes on the second run.\n                            // Do a change detection run with checkNoChanges set to true to check\n                            // there are no changes on the second run.\n                            _this.detectChanges(true);\n                        }\n                    }\n                });\n                _this._onStableSubscription = ngZone.onStable.subscribe({\n                    next: function () {\n                        _this._isStable = true;\n                        // Check whether there is a pending whenStable() completer to resolve.\n                        if (_this._promise !== null) {\n                            // If so check whether there are no pending macrotasks before resolving.\n                            // Do this check in the next tick so that ngZone gets a chance to update the state of\n                            // pending macrotasks.\n                            scheduleMicroTask(function () {\n                                if (!ngZone.hasPendingMacrotasks) {\n                                    if (_this._promise !== null) {\n                                        _this._resolve(true);\n                                        _this._resolve = null;\n                                        _this._promise = null;\n                                    }\n                                }\n                            });\n                        }\n                    }\n                });\n                _this._onErrorSubscription =\n                    ngZone.onError.subscribe({ next: function (error) { throw error; } });\n            });\n        }\n    }\n    ComponentFixture.prototype._tick = function (checkNoChanges) {\n        this.changeDetectorRef.detectChanges();\n        if (checkNoChanges) {\n            this.checkNoChanges();\n        }\n    };\n    /**\n     * Trigger a change detection cycle for the component.\n     */\n    /**\n       * Trigger a change detection cycle for the component.\n       */\n    ComponentFixture.prototype.detectChanges = /**\n       * Trigger a change detection cycle for the component.\n       */\n    function (checkNoChanges) {\n        var _this = this;\n        if (checkNoChanges === void 0) { checkNoChanges = true; }\n        if (this.ngZone != null) {\n            // Run the change detection inside the NgZone so that any async tasks as part of the change\n            // detection are captured by the zone and can be waited for in isStable.\n            this.ngZone.run(function () { _this._tick(checkNoChanges); });\n        }\n        else {\n            // Running without zone. Just do the change detection.\n            this._tick(checkNoChanges);\n        }\n    };\n    /**\n     * Do a change detection run to make sure there were no changes.\n     */\n    /**\n       * Do a change detection run to make sure there were no changes.\n       */\n    ComponentFixture.prototype.checkNoChanges = /**\n       * Do a change detection run to make sure there were no changes.\n       */\n    function () { this.changeDetectorRef.checkNoChanges(); };\n    /**\n     * Set whether the fixture should autodetect changes.\n     *\n     * Also runs detectChanges once so that any existing change is detected.\n     */\n    /**\n       * Set whether the fixture should autodetect changes.\n       *\n       * Also runs detectChanges once so that any existing change is detected.\n       */\n    ComponentFixture.prototype.autoDetectChanges = /**\n       * Set whether the fixture should autodetect changes.\n       *\n       * Also runs detectChanges once so that any existing change is detected.\n       */\n    function (autoDetect) {\n        if (autoDetect === void 0) { autoDetect = true; }\n        if (this.ngZone == null) {\n            throw new Error('Cannot call autoDetectChanges when ComponentFixtureNoNgZone is set');\n        }\n        this._autoDetect = autoDetect;\n        this.detectChanges();\n    };\n    /**\n     * Return whether the fixture is currently stable or has async tasks that have not been completed\n     * yet.\n     */\n    /**\n       * Return whether the fixture is currently stable or has async tasks that have not been completed\n       * yet.\n       */\n    ComponentFixture.prototype.isStable = /**\n       * Return whether the fixture is currently stable or has async tasks that have not been completed\n       * yet.\n       */\n    function () { return this._isStable && !this.ngZone.hasPendingMacrotasks; };\n    /**\n     * Get a promise that resolves when the fixture is stable.\n     *\n     * This can be used to resume testing after events have triggered asynchronous activity or\n     * asynchronous change detection.\n     */\n    /**\n       * Get a promise that resolves when the fixture is stable.\n       *\n       * This can be used to resume testing after events have triggered asynchronous activity or\n       * asynchronous change detection.\n       */\n    ComponentFixture.prototype.whenStable = /**\n       * Get a promise that resolves when the fixture is stable.\n       *\n       * This can be used to resume testing after events have triggered asynchronous activity or\n       * asynchronous change detection.\n       */\n    function () {\n        var _this = this;\n        if (this.isStable()) {\n            return Promise.resolve(false);\n        }\n        else if (this._promise !== null) {\n            return this._promise;\n        }\n        else {\n            this._promise = new Promise(function (res) { _this._resolve = res; });\n            return this._promise;\n        }\n    };\n    ComponentFixture.prototype._getRenderer = function () {\n        if (this._renderer === undefined) {\n            this._renderer = this.componentRef.injector.get(RendererFactory2, null);\n        }\n        return this._renderer;\n    };\n    /**\n      * Get a promise that resolves when the ui state is stable following animations.\n      */\n    /**\n        * Get a promise that resolves when the ui state is stable following animations.\n        */\n    ComponentFixture.prototype.whenRenderingDone = /**\n        * Get a promise that resolves when the ui state is stable following animations.\n        */\n    function () {\n        var renderer = this._getRenderer();\n        if (renderer && renderer.whenRenderingDone) {\n            return renderer.whenRenderingDone();\n        }\n        return this.whenStable();\n    };\n    /**\n     * Trigger component destruction.\n     */\n    /**\n       * Trigger component destruction.\n       */\n    ComponentFixture.prototype.destroy = /**\n       * Trigger component destruction.\n       */\n    function () {\n        if (!this._isDestroyed) {\n            this.componentRef.destroy();\n            if (this._onUnstableSubscription != null) {\n                this._onUnstableSubscription.unsubscribe();\n                this._onUnstableSubscription = null;\n            }\n            if (this._onStableSubscription != null) {\n                this._onStableSubscription.unsubscribe();\n                this._onStableSubscription = null;\n            }\n            if (this._onMicrotaskEmptySubscription != null) {\n                this._onMicrotaskEmptySubscription.unsubscribe();\n                this._onMicrotaskEmptySubscription = null;\n            }\n            if (this._onErrorSubscription != null) {\n                this._onErrorSubscription.unsubscribe();\n                this._onErrorSubscription = null;\n            }\n            this._isDestroyed = true;\n        }\n    };\n    return ComponentFixture;\n}());\n/**\n * Fixture for debugging and testing a component.\n *\n *\n */\nexport { ComponentFixture };\nfunction scheduleMicroTask(fn) {\n    Zone.current.scheduleMicroTask('scheduleMicrotask', fn);\n}\n//# sourceMappingURL=component_fixture.js.map","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * fakeAsync has been moved to zone.js\n * this file is for fallback in case old version of zone.js is used\n */\nvar _Zone = typeof Zone !== 'undefined' ? Zone : null;\nvar FakeAsyncTestZoneSpec = _Zone && _Zone['FakeAsyncTestZoneSpec'];\nvar ProxyZoneSpec = _Zone && _Zone['ProxyZoneSpec'];\nvar _fakeAsyncTestZoneSpec = null;\n/**\n * Clears out the shared fake async zone for a test.\n * To be called in a global `beforeEach`.\n *\n * @experimental\n */\nexport function resetFakeAsyncZoneFallback() {\n    _fakeAsyncTestZoneSpec = null;\n    // in node.js testing we may not have ProxyZoneSpec in which case there is nothing to reset.\n    ProxyZoneSpec && ProxyZoneSpec.assertPresent().resetDelegate();\n}\nvar _inFakeAsyncCall = false;\n/**\n * Wraps a function to be executed in the fakeAsync zone:\n * - microtasks are manually executed by calling `flushMicrotasks()`,\n * - timers are synchronous, `tick()` simulates the asynchronous passage of time.\n *\n * If there are any pending timers at the end of the function, an exception will be thrown.\n *\n * Can be used to wrap inject() calls.\n *\n * ## Example\n *\n * {@example core/testing/ts/fake_async.ts region='basic'}\n *\n * @param fn\n * @returns The function wrapped to be executed in the fakeAsync zone\n *\n * @experimental\n */\nexport function fakeAsyncFallback(fn) {\n    // Not using an arrow function to preserve context passed from call site\n    return function () {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n        }\n        var proxyZoneSpec = ProxyZoneSpec.assertPresent();\n        if (_inFakeAsyncCall) {\n            throw new Error('fakeAsync() calls can not be nested');\n        }\n        _inFakeAsyncCall = true;\n        try {\n            if (!_fakeAsyncTestZoneSpec) {\n                if (proxyZoneSpec.getDelegate() instanceof FakeAsyncTestZoneSpec) {\n                    throw new Error('fakeAsync() calls can not be nested');\n                }\n                _fakeAsyncTestZoneSpec = new FakeAsyncTestZoneSpec();\n            }\n            var res = void 0;\n            var lastProxyZoneSpec = proxyZoneSpec.getDelegate();\n            proxyZoneSpec.setDelegate(_fakeAsyncTestZoneSpec);\n            try {\n                res = fn.apply(this, args);\n                flushMicrotasksFallback();\n            }\n            finally {\n                proxyZoneSpec.setDelegate(lastProxyZoneSpec);\n            }\n            if (_fakeAsyncTestZoneSpec.pendingPeriodicTimers.length > 0) {\n                throw new Error(_fakeAsyncTestZoneSpec.pendingPeriodicTimers.length + \" \" +\n                    \"periodic timer(s) still in the queue.\");\n            }\n            if (_fakeAsyncTestZoneSpec.pendingTimers.length > 0) {\n                throw new Error(_fakeAsyncTestZoneSpec.pendingTimers.length + \" timer(s) still in the queue.\");\n            }\n            return res;\n        }\n        finally {\n            _inFakeAsyncCall = false;\n            resetFakeAsyncZoneFallback();\n        }\n    };\n}\nfunction _getFakeAsyncZoneSpec() {\n    if (_fakeAsyncTestZoneSpec == null) {\n        throw new Error('The code should be running in the fakeAsync zone to call this function');\n    }\n    return _fakeAsyncTestZoneSpec;\n}\n/**\n * Simulates the asynchronous passage of time for the timers in the fakeAsync zone.\n *\n * The microtasks queue is drained at the very start of this function and after any timer callback\n * has been executed.\n *\n * ## Example\n *\n * {@example core/testing/ts/fake_async.ts region='basic'}\n *\n * @experimental\n */\nexport function tickFallback(millis) {\n    if (millis === void 0) { millis = 0; }\n    _getFakeAsyncZoneSpec().tick(millis);\n}\n/**\n * Simulates the asynchronous passage of time for the timers in the fakeAsync zone by\n * draining the macrotask queue until it is empty. The returned value is the milliseconds\n * of time that would have been elapsed.\n *\n * @param maxTurns\n * @returns The simulated time elapsed, in millis.\n *\n * @experimental\n */\nexport function flushFallback(maxTurns) {\n    return _getFakeAsyncZoneSpec().flush(maxTurns);\n}\n/**\n * Discard all remaining periodic tasks.\n *\n * @experimental\n */\nexport function discardPeriodicTasksFallback() {\n    var zoneSpec = _getFakeAsyncZoneSpec();\n    var pendingTimers = zoneSpec.pendingPeriodicTimers;\n    zoneSpec.pendingPeriodicTimers.length = 0;\n}\n/**\n * Flush any pending microtasks.\n *\n * @experimental\n */\nexport function flushMicrotasksFallback() {\n    _getFakeAsyncZoneSpec().flushMicrotasks();\n}\n//# sourceMappingURL=fake_async_fallback.js.map","import { discardPeriodicTasksFallback, fakeAsyncFallback, flushFallback, flushMicrotasksFallback, resetFakeAsyncZoneFallback, tickFallback } from './fake_async_fallback';\nvar _Zone = typeof Zone !== 'undefined' ? Zone : null;\nvar fakeAsyncTestModule = _Zone && _Zone[_Zone.__symbol__('fakeAsyncTest')];\n/**\n * Clears out the shared fake async zone for a test.\n * To be called in a global `beforeEach`.\n *\n * @experimental\n */\nexport function resetFakeAsyncZone() {\n    if (fakeAsyncTestModule) {\n        return fakeAsyncTestModule.resetFakeAsyncZone();\n    }\n    else {\n        return resetFakeAsyncZoneFallback();\n    }\n}\n/**\n * Wraps a function to be executed in the fakeAsync zone:\n * - microtasks are manually executed by calling `flushMicrotasks()`,\n * - timers are synchronous, `tick()` simulates the asynchronous passage of time.\n *\n * If there are any pending timers at the end of the function, an exception will be thrown.\n *\n * Can be used to wrap inject() calls.\n *\n * ## Example\n *\n * {@example core/testing/ts/fake_async.ts region='basic'}\n *\n * @param fn\n * @returns The function wrapped to be executed in the fakeAsync zone\n *\n * @experimental\n */\nexport function fakeAsync(fn) {\n    if (fakeAsyncTestModule) {\n        return fakeAsyncTestModule.fakeAsync(fn);\n    }\n    else {\n        return fakeAsyncFallback(fn);\n    }\n}\n/**\n * Simulates the asynchronous passage of time for the timers in the fakeAsync zone.\n *\n * The microtasks queue is drained at the very start of this function and after any timer callback\n * has been executed.\n *\n * ## Example\n *\n * {@example core/testing/ts/fake_async.ts region='basic'}\n *\n * @experimental\n */\nexport function tick(millis) {\n    if (millis === void 0) { millis = 0; }\n    if (fakeAsyncTestModule) {\n        return fakeAsyncTestModule.tick(millis);\n    }\n    else {\n        return tickFallback(millis);\n    }\n}\n/**\n * Simulates the asynchronous passage of time for the timers in the fakeAsync zone by\n * draining the macrotask queue until it is empty. The returned value is the milliseconds\n * of time that would have been elapsed.\n *\n * @param maxTurns\n * @returns The simulated time elapsed, in millis.\n *\n * @experimental\n */\nexport function flush(maxTurns) {\n    if (fakeAsyncTestModule) {\n        return fakeAsyncTestModule.flush(maxTurns);\n    }\n    else {\n        return flushFallback(maxTurns);\n    }\n}\n/**\n * Discard all remaining periodic tasks.\n *\n * @experimental\n */\nexport function discardPeriodicTasks() {\n    if (fakeAsyncTestModule) {\n        return fakeAsyncTestModule.discardPeriodicTasks();\n    }\n    else {\n        discardPeriodicTasksFallback();\n    }\n}\n/**\n * Flush any pending microtasks.\n *\n * @experimental\n */\nexport function flushMicrotasks() {\n    if (fakeAsyncTestModule) {\n        return fakeAsyncTestModule.flushMicrotasks();\n    }\n    else {\n        return flushMicrotasksFallback();\n    }\n}\n//# sourceMappingURL=fake_async.js.map","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Injectable completer that allows signaling completion of an asynchronous test. Used internally.\n */\nvar /**\n * Injectable completer that allows signaling completion of an asynchronous test. Used internally.\n */\nAsyncTestCompleter = /** @class */ (function () {\n    function AsyncTestCompleter() {\n        var _this = this;\n        this._promise = new Promise(function (res, rej) {\n            _this._resolve = res;\n            _this._reject = rej;\n        });\n    }\n    AsyncTestCompleter.prototype.done = function (value) { this._resolve(value); };\n    AsyncTestCompleter.prototype.fail = function (error, stackTrace) { this._reject(error); };\n    Object.defineProperty(AsyncTestCompleter.prototype, \"promise\", {\n        get: function () { return this._promise; },\n        enumerable: true,\n        configurable: true\n    });\n    return AsyncTestCompleter;\n}());\n/**\n * Injectable completer that allows signaling completion of an asynchronous test. Used internally.\n */\nexport { AsyncTestCompleter };\n//# sourceMappingURL=async_test_completer.js.map","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport * as tslib_1 from \"tslib\";\nimport { Compiler, Injectable } from '@angular/core';\nfunction unimplemented() {\n    throw Error('unimplemented');\n}\n/**\n * Special interface to the compiler only used by testing\n *\n * @experimental\n */\nvar TestingCompiler = /** @class */ (function (_super) {\n    tslib_1.__extends(TestingCompiler, _super);\n    function TestingCompiler() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Object.defineProperty(TestingCompiler.prototype, \"injector\", {\n        get: function () { throw unimplemented(); },\n        enumerable: true,\n        configurable: true\n    });\n    TestingCompiler.prototype.overrideModule = function (module, overrides) {\n        throw unimplemented();\n    };\n    TestingCompiler.prototype.overrideDirective = function (directive, overrides) {\n        throw unimplemented();\n    };\n    TestingCompiler.prototype.overrideComponent = function (component, overrides) {\n        throw unimplemented();\n    };\n    TestingCompiler.prototype.overridePipe = function (directive, overrides) {\n        throw unimplemented();\n    };\n    /**\n     * Allows to pass the compile summary from AOT compilation to the JIT compiler,\n     * so that it can use the code generated by AOT.\n     */\n    /**\n       * Allows to pass the compile summary from AOT compilation to the JIT compiler,\n       * so that it can use the code generated by AOT.\n       */\n    TestingCompiler.prototype.loadAotSummaries = /**\n       * Allows to pass the compile summary from AOT compilation to the JIT compiler,\n       * so that it can use the code generated by AOT.\n       */\n    function (summaries) { throw unimplemented(); };\n    /**\n     * Gets the component factory for the given component.\n     * This assumes that the component has been compiled before calling this call using\n     * `compileModuleAndAllComponents*`.\n     */\n    /**\n       * Gets the component factory for the given component.\n       * This assumes that the component has been compiled before calling this call using\n       * `compileModuleAndAllComponents*`.\n       */\n    TestingCompiler.prototype.getComponentFactory = /**\n       * Gets the component factory for the given component.\n       * This assumes that the component has been compiled before calling this call using\n       * `compileModuleAndAllComponents*`.\n       */\n    function (component) { throw unimplemented(); };\n    /**\n     * Returns the component type that is stored in the given error.\n     * This can be used for errors created by compileModule...\n     */\n    /**\n       * Returns the component type that is stored in the given error.\n       * This can be used for errors created by compileModule...\n       */\n    TestingCompiler.prototype.getComponentFromError = /**\n       * Returns the component type that is stored in the given error.\n       * This can be used for errors created by compileModule...\n       */\n    function (error) { throw unimplemented(); };\n    TestingCompiler.decorators = [\n        { type: Injectable },\n    ];\n    /** @nocollapse */\n    TestingCompiler.ctorParameters = function () { return []; };\n    return TestingCompiler;\n}(Compiler));\nexport { TestingCompiler };\n/**\n * A factory for creating a Compiler\n *\n * @experimental\n */\nvar /**\n * A factory for creating a Compiler\n *\n * @experimental\n */\nTestingCompilerFactory = /** @class */ (function () {\n    function TestingCompilerFactory() {\n    }\n    return TestingCompilerFactory;\n}());\n/**\n * A factory for creating a Compiler\n *\n * @experimental\n */\nexport { TestingCompilerFactory };\n//# sourceMappingURL=test_compiler.js.map","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { ApplicationInitStatus, Component, InjectionToken, Injector, NgModule, NgZone, Optional, SkipSelf, ɵAPP_ROOT as APP_ROOT, ɵclearOverrides as clearOverrides, ɵoverrideComponentView as overrideComponentView, ɵoverrideProvider as overrideProvider, ɵstringify as stringify } from '@angular/core';\nimport { AsyncTestCompleter } from './async_test_completer';\nimport { ComponentFixture } from './component_fixture';\nimport { TestingCompilerFactory } from './test_compiler';\nvar UNDEFINED = new Object();\n/**\n * An abstract class for inserting the root test component element in a platform independent way.\n *\n * @experimental\n */\nvar /**\n * An abstract class for inserting the root test component element in a platform independent way.\n *\n * @experimental\n */\nTestComponentRenderer = /** @class */ (function () {\n    function TestComponentRenderer() {\n    }\n    TestComponentRenderer.prototype.insertRootElement = function (rootElementId) { };\n    return TestComponentRenderer;\n}());\n/**\n * An abstract class for inserting the root test component element in a platform independent way.\n *\n * @experimental\n */\nexport { TestComponentRenderer };\nvar _nextRootElementId = 0;\n/**\n * @experimental\n */\nexport var ComponentFixtureAutoDetect = new InjectionToken('ComponentFixtureAutoDetect');\n/**\n * @experimental\n */\nexport var ComponentFixtureNoNgZone = new InjectionToken('ComponentFixtureNoNgZone');\n/**\n * @description\n * Configures and initializes environment for unit testing and provides methods for\n * creating components and services in unit tests.\n *\n * TestBed is the primary api for writing unit tests for Angular applications and libraries.\n *\n *\n */\nvar /**\n * @description\n * Configures and initializes environment for unit testing and provides methods for\n * creating components and services in unit tests.\n *\n * TestBed is the primary api for writing unit tests for Angular applications and libraries.\n *\n *\n */\nTestBed = /** @class */ (function () {\n    function TestBed() {\n        this._instantiated = false;\n        this._compiler = null;\n        this._moduleRef = null;\n        this._moduleFactory = null;\n        this._compilerOptions = [];\n        this._moduleOverrides = [];\n        this._componentOverrides = [];\n        this._directiveOverrides = [];\n        this._pipeOverrides = [];\n        this._providers = [];\n        this._declarations = [];\n        this._imports = [];\n        this._schemas = [];\n        this._activeFixtures = [];\n        this._testEnvAotSummaries = function () { return []; };\n        this._aotSummaries = [];\n        this._templateOverrides = [];\n        this._isRoot = true;\n        this._rootProviderOverrides = [];\n        this.platform = null;\n        this.ngModule = null;\n    }\n    /**\n     * Initialize the environment for testing with a compiler factory, a PlatformRef, and an\n     * angular module. These are common to every test in the suite.\n     *\n     * This may only be called once, to set up the common providers for the current test\n     * suite on the current platform. If you absolutely need to change the providers,\n     * first use `resetTestEnvironment`.\n     *\n     * Test modules and platforms for individual platforms are available from\n     * '@angular/<platform_name>/testing'.\n     *\n     * @experimental\n     */\n    /**\n       * Initialize the environment for testing with a compiler factory, a PlatformRef, and an\n       * angular module. These are common to every test in the suite.\n       *\n       * This may only be called once, to set up the common providers for the current test\n       * suite on the current platform. If you absolutely need to change the providers,\n       * first use `resetTestEnvironment`.\n       *\n       * Test modules and platforms for individual platforms are available from\n       * '@angular/<platform_name>/testing'.\n       *\n       * @experimental\n       */\n    TestBed.initTestEnvironment = /**\n       * Initialize the environment for testing with a compiler factory, a PlatformRef, and an\n       * angular module. These are common to every test in the suite.\n       *\n       * This may only be called once, to set up the common providers for the current test\n       * suite on the current platform. If you absolutely need to change the providers,\n       * first use `resetTestEnvironment`.\n       *\n       * Test modules and platforms for individual platforms are available from\n       * '@angular/<platform_name>/testing'.\n       *\n       * @experimental\n       */\n    function (ngModule, platform, aotSummaries) {\n        var testBed = getTestBed();\n        testBed.initTestEnvironment(ngModule, platform, aotSummaries);\n        return testBed;\n    };\n    /**\n     * Reset the providers for the test injector.\n     *\n     * @experimental\n     */\n    /**\n       * Reset the providers for the test injector.\n       *\n       * @experimental\n       */\n    TestBed.resetTestEnvironment = /**\n       * Reset the providers for the test injector.\n       *\n       * @experimental\n       */\n    function () { getTestBed().resetTestEnvironment(); };\n    TestBed.resetTestingModule = function () {\n        getTestBed().resetTestingModule();\n        return TestBed;\n    };\n    /**\n     * Allows overriding default compiler providers and settings\n     * which are defined in test_injector.js\n     */\n    /**\n       * Allows overriding default compiler providers and settings\n       * which are defined in test_injector.js\n       */\n    TestBed.configureCompiler = /**\n       * Allows overriding default compiler providers and settings\n       * which are defined in test_injector.js\n       */\n    function (config) {\n        getTestBed().configureCompiler(config);\n        return TestBed;\n    };\n    /**\n     * Allows overriding default providers, directives, pipes, modules of the test injector,\n     * which are defined in test_injector.js\n     */\n    /**\n       * Allows overriding default providers, directives, pipes, modules of the test injector,\n       * which are defined in test_injector.js\n       */\n    TestBed.configureTestingModule = /**\n       * Allows overriding default providers, directives, pipes, modules of the test injector,\n       * which are defined in test_injector.js\n       */\n    function (moduleDef) {\n        getTestBed().configureTestingModule(moduleDef);\n        return TestBed;\n    };\n    /**\n     * Compile components with a `templateUrl` for the test's NgModule.\n     * It is necessary to call this function\n     * as fetching urls is asynchronous.\n     */\n    /**\n       * Compile components with a `templateUrl` for the test's NgModule.\n       * It is necessary to call this function\n       * as fetching urls is asynchronous.\n       */\n    TestBed.compileComponents = /**\n       * Compile components with a `templateUrl` for the test's NgModule.\n       * It is necessary to call this function\n       * as fetching urls is asynchronous.\n       */\n    function () { return getTestBed().compileComponents(); };\n    TestBed.overrideModule = function (ngModule, override) {\n        getTestBed().overrideModule(ngModule, override);\n        return TestBed;\n    };\n    TestBed.overrideComponent = function (component, override) {\n        getTestBed().overrideComponent(component, override);\n        return TestBed;\n    };\n    TestBed.overrideDirective = function (directive, override) {\n        getTestBed().overrideDirective(directive, override);\n        return TestBed;\n    };\n    TestBed.overridePipe = function (pipe, override) {\n        getTestBed().overridePipe(pipe, override);\n        return TestBed;\n    };\n    TestBed.overrideTemplate = function (component, template) {\n        getTestBed().overrideComponent(component, { set: { template: template, templateUrl: (null) } });\n        return TestBed;\n    };\n    /**\n     * Overrides the template of the given component, compiling the template\n     * in the context of the TestingModule.\n     *\n     * Note: This works for JIT and AOTed components as well.\n     */\n    /**\n       * Overrides the template of the given component, compiling the template\n       * in the context of the TestingModule.\n       *\n       * Note: This works for JIT and AOTed components as well.\n       */\n    TestBed.overrideTemplateUsingTestingModule = /**\n       * Overrides the template of the given component, compiling the template\n       * in the context of the TestingModule.\n       *\n       * Note: This works for JIT and AOTed components as well.\n       */\n    function (component, template) {\n        getTestBed().overrideTemplateUsingTestingModule(component, template);\n        return TestBed;\n    };\n    TestBed.overrideProvider = function (token, provider) {\n        getTestBed().overrideProvider(token, provider);\n        return TestBed;\n    };\n    TestBed.deprecatedOverrideProvider = function (token, provider) {\n        getTestBed().deprecatedOverrideProvider(token, provider);\n        return TestBed;\n    };\n    TestBed.get = function (token, notFoundValue) {\n        if (notFoundValue === void 0) { notFoundValue = Injector.THROW_IF_NOT_FOUND; }\n        return getTestBed().get(token, notFoundValue);\n    };\n    TestBed.createComponent = function (component) {\n        return getTestBed().createComponent(component);\n    };\n    /**\n     * Initialize the environment for testing with a compiler factory, a PlatformRef, and an\n     * angular module. These are common to every test in the suite.\n     *\n     * This may only be called once, to set up the common providers for the current test\n     * suite on the current platform. If you absolutely need to change the providers,\n     * first use `resetTestEnvironment`.\n     *\n     * Test modules and platforms for individual platforms are available from\n     * '@angular/<platform_name>/testing'.\n     *\n     * @experimental\n     */\n    /**\n       * Initialize the environment for testing with a compiler factory, a PlatformRef, and an\n       * angular module. These are common to every test in the suite.\n       *\n       * This may only be called once, to set up the common providers for the current test\n       * suite on the current platform. If you absolutely need to change the providers,\n       * first use `resetTestEnvironment`.\n       *\n       * Test modules and platforms for individual platforms are available from\n       * '@angular/<platform_name>/testing'.\n       *\n       * @experimental\n       */\n    TestBed.prototype.initTestEnvironment = /**\n       * Initialize the environment for testing with a compiler factory, a PlatformRef, and an\n       * angular module. These are common to every test in the suite.\n       *\n       * This may only be called once, to set up the common providers for the current test\n       * suite on the current platform. If you absolutely need to change the providers,\n       * first use `resetTestEnvironment`.\n       *\n       * Test modules and platforms for individual platforms are available from\n       * '@angular/<platform_name>/testing'.\n       *\n       * @experimental\n       */\n    function (ngModule, platform, aotSummaries) {\n        if (this.platform || this.ngModule) {\n            throw new Error('Cannot set base providers because it has already been called');\n        }\n        this.platform = platform;\n        this.ngModule = ngModule;\n        if (aotSummaries) {\n            this._testEnvAotSummaries = aotSummaries;\n        }\n    };\n    /**\n     * Reset the providers for the test injector.\n     *\n     * @experimental\n     */\n    /**\n       * Reset the providers for the test injector.\n       *\n       * @experimental\n       */\n    TestBed.prototype.resetTestEnvironment = /**\n       * Reset the providers for the test injector.\n       *\n       * @experimental\n       */\n    function () {\n        this.resetTestingModule();\n        this.platform = (null);\n        this.ngModule = (null);\n        this._testEnvAotSummaries = function () { return []; };\n    };\n    TestBed.prototype.resetTestingModule = function () {\n        clearOverrides();\n        this._aotSummaries = [];\n        this._templateOverrides = [];\n        this._compiler = (null);\n        this._moduleOverrides = [];\n        this._componentOverrides = [];\n        this._directiveOverrides = [];\n        this._pipeOverrides = [];\n        this._isRoot = true;\n        this._rootProviderOverrides = [];\n        this._moduleRef = (null);\n        this._moduleFactory = (null);\n        this._compilerOptions = [];\n        this._providers = [];\n        this._declarations = [];\n        this._imports = [];\n        this._schemas = [];\n        this._instantiated = false;\n        this._activeFixtures.forEach(function (fixture) {\n            try {\n                fixture.destroy();\n            }\n            catch (e) {\n                console.error('Error during cleanup of component', {\n                    component: fixture.componentInstance,\n                    stacktrace: e,\n                });\n            }\n        });\n        this._activeFixtures = [];\n    };\n    TestBed.prototype.configureCompiler = function (config) {\n        this._assertNotInstantiated('TestBed.configureCompiler', 'configure the compiler');\n        this._compilerOptions.push(config);\n    };\n    TestBed.prototype.configureTestingModule = function (moduleDef) {\n        this._assertNotInstantiated('TestBed.configureTestingModule', 'configure the test module');\n        if (moduleDef.providers) {\n            (_a = this._providers).push.apply(_a, moduleDef.providers);\n        }\n        if (moduleDef.declarations) {\n            (_b = this._declarations).push.apply(_b, moduleDef.declarations);\n        }\n        if (moduleDef.imports) {\n            (_c = this._imports).push.apply(_c, moduleDef.imports);\n        }\n        if (moduleDef.schemas) {\n            (_d = this._schemas).push.apply(_d, moduleDef.schemas);\n        }\n        if (moduleDef.aotSummaries) {\n            this._aotSummaries.push(moduleDef.aotSummaries);\n        }\n        var _a, _b, _c, _d;\n    };\n    TestBed.prototype.compileComponents = function () {\n        var _this = this;\n        if (this._moduleFactory || this._instantiated) {\n            return Promise.resolve(null);\n        }\n        var moduleType = this._createCompilerAndModule();\n        return this._compiler.compileModuleAndAllComponentsAsync(moduleType)\n            .then(function (moduleAndComponentFactories) {\n            _this._moduleFactory = moduleAndComponentFactories.ngModuleFactory;\n        });\n    };\n    TestBed.prototype._initIfNeeded = function () {\n        if (this._instantiated) {\n            return;\n        }\n        if (!this._moduleFactory) {\n            try {\n                var moduleType = this._createCompilerAndModule();\n                this._moduleFactory =\n                    this._compiler.compileModuleAndAllComponentsSync(moduleType).ngModuleFactory;\n            }\n            catch (e) {\n                var errorCompType = this._compiler.getComponentFromError(e);\n                if (errorCompType) {\n                    throw new Error(\"This test module uses the component \" + stringify(errorCompType) + \" which is using a \\\"templateUrl\\\" or \\\"styleUrls\\\", but they were never compiled. \" +\n                        \"Please call \\\"TestBed.compileComponents\\\" before your test.\");\n                }\n                else {\n                    throw e;\n                }\n            }\n        }\n        for (var _i = 0, _a = this._templateOverrides; _i < _a.length; _i++) {\n            var _b = _a[_i], component = _b.component, templateOf = _b.templateOf;\n            var compFactory = this._compiler.getComponentFactory(templateOf);\n            overrideComponentView(component, compFactory);\n        }\n        var ngZone = new NgZone({ enableLongStackTrace: true });\n        var providers = [{ provide: NgZone, useValue: ngZone }];\n        var ngZoneInjector = Injector.create({\n            providers: providers,\n            parent: this.platform.injector,\n            name: this._moduleFactory.moduleType.name\n        });\n        this._moduleRef = this._moduleFactory.create(ngZoneInjector);\n        // ApplicationInitStatus.runInitializers() is marked @internal to core. So casting to any\n        // before accessing it.\n        // ApplicationInitStatus.runInitializers() is marked @internal to core. So casting to any\n        // before accessing it.\n        this._moduleRef.injector.get(ApplicationInitStatus).runInitializers();\n        this._instantiated = true;\n    };\n    TestBed.prototype._createCompilerAndModule = function () {\n        var _this = this;\n        var providers = this._providers.concat([{ provide: TestBed, useValue: this }]);\n        var declarations = this._declarations.concat(this._templateOverrides.map(function (entry) { return entry.templateOf; }));\n        var rootScopeImports = [];\n        var rootProviderOverrides = this._rootProviderOverrides;\n        if (this._isRoot) {\n            var RootScopeModule = /** @class */ (function () {\n                function RootScopeModule() {\n                }\n                RootScopeModule.decorators = [\n                    { type: NgModule, args: [{\n                                providers: rootProviderOverrides.slice(),\n                            },] },\n                ];\n                /** @nocollapse */\n                RootScopeModule.ctorParameters = function () { return []; };\n                return RootScopeModule;\n            }());\n            rootScopeImports.push(RootScopeModule);\n        }\n        providers.push({ provide: APP_ROOT, useValue: this._isRoot });\n        var imports = [rootScopeImports, this.ngModule, this._imports];\n        var schemas = this._schemas;\n        var DynamicTestModule = /** @class */ (function () {\n            function DynamicTestModule() {\n            }\n            DynamicTestModule.decorators = [\n                { type: NgModule, args: [{ providers: providers, declarations: declarations, imports: imports, schemas: schemas },] },\n            ];\n            /** @nocollapse */\n            DynamicTestModule.ctorParameters = function () { return []; };\n            return DynamicTestModule;\n        }());\n        var compilerFactory = this.platform.injector.get(TestingCompilerFactory);\n        this._compiler = compilerFactory.createTestingCompiler(this._compilerOptions);\n        for (var _i = 0, _a = [this._testEnvAotSummaries].concat(this._aotSummaries); _i < _a.length; _i++) {\n            var summary = _a[_i];\n            this._compiler.loadAotSummaries(summary);\n        }\n        this._moduleOverrides.forEach(function (entry) { return _this._compiler.overrideModule(entry[0], entry[1]); });\n        this._componentOverrides.forEach(function (entry) { return _this._compiler.overrideComponent(entry[0], entry[1]); });\n        this._directiveOverrides.forEach(function (entry) { return _this._compiler.overrideDirective(entry[0], entry[1]); });\n        this._pipeOverrides.forEach(function (entry) { return _this._compiler.overridePipe(entry[0], entry[1]); });\n        return DynamicTestModule;\n    };\n    TestBed.prototype._assertNotInstantiated = function (methodName, methodDescription) {\n        if (this._instantiated) {\n            throw new Error(\"Cannot \" + methodDescription + \" when the test module has already been instantiated. \" +\n                (\"Make sure you are not using `inject` before `\" + methodName + \"`.\"));\n        }\n    };\n    TestBed.prototype.get = function (token, notFoundValue) {\n        if (notFoundValue === void 0) { notFoundValue = Injector.THROW_IF_NOT_FOUND; }\n        this._initIfNeeded();\n        if (token === TestBed) {\n            return this;\n        }\n        // Tests can inject things from the ng module and from the compiler,\n        // but the ng module can't inject things from the compiler and vice versa.\n        var result = this._moduleRef.injector.get(token, UNDEFINED);\n        return result === UNDEFINED ? this._compiler.injector.get(token, notFoundValue) : result;\n    };\n    TestBed.prototype.execute = function (tokens, fn, context) {\n        var _this = this;\n        this._initIfNeeded();\n        var params = tokens.map(function (t) { return _this.get(t); });\n        return fn.apply(context, params);\n    };\n    TestBed.prototype.overrideModule = function (ngModule, override) {\n        this._assertNotInstantiated('overrideModule', 'override module metadata');\n        this._moduleOverrides.push([ngModule, override]);\n    };\n    TestBed.prototype.overrideComponent = function (component, override) {\n        this._assertNotInstantiated('overrideComponent', 'override component metadata');\n        this._componentOverrides.push([component, override]);\n    };\n    TestBed.prototype.overrideDirective = function (directive, override) {\n        this._assertNotInstantiated('overrideDirective', 'override directive metadata');\n        this._directiveOverrides.push([directive, override]);\n    };\n    TestBed.prototype.overridePipe = function (pipe, override) {\n        this._assertNotInstantiated('overridePipe', 'override pipe metadata');\n        this._pipeOverrides.push([pipe, override]);\n    };\n    TestBed.prototype.overrideProvider = function (token, provider) {\n        this.overrideProviderImpl(token, provider);\n    };\n    TestBed.prototype.deprecatedOverrideProvider = function (token, provider) {\n        this.overrideProviderImpl(token, provider, /* deprecated */ /* deprecated */ true);\n    };\n    TestBed.prototype.overrideProviderImpl = function (token, provider, deprecated) {\n        if (deprecated === void 0) { deprecated = false; }\n        if (typeof token !== 'string' && token.ngInjectableDef &&\n            token.ngInjectableDef.providedIn === 'root') {\n            if (provider.useFactory) {\n                this._rootProviderOverrides.push({ provide: token, useFactory: provider.useFactory, deps: provider.deps || [] });\n            }\n            else {\n                this._rootProviderOverrides.push({ provide: token, useValue: provider.useValue });\n            }\n        }\n        var flags = 0;\n        var value;\n        if (provider.useFactory) {\n            flags |= 1024 /* TypeFactoryProvider */;\n            value = provider.useFactory;\n        }\n        else {\n            flags |= 256 /* TypeValueProvider */;\n            value = provider.useValue;\n        }\n        var deps = (provider.deps || []).map(function (dep) {\n            var depFlags = 0 /* None */;\n            var depToken;\n            if (Array.isArray(dep)) {\n                dep.forEach(function (entry) {\n                    if (entry instanceof Optional) {\n                        depFlags |= 2 /* Optional */;\n                    }\n                    else if (entry instanceof SkipSelf) {\n                        depFlags |= 1 /* SkipSelf */;\n                    }\n                    else {\n                        depToken = entry;\n                    }\n                });\n            }\n            else {\n                depToken = dep;\n            }\n            return [depFlags, depToken];\n        });\n        overrideProvider({ token: token, flags: flags, deps: deps, value: value, deprecatedBehavior: deprecated });\n    };\n    TestBed.prototype.overrideTemplateUsingTestingModule = function (component, template) {\n        this._assertNotInstantiated('overrideTemplateUsingTestingModule', 'override template');\n        var OverrideComponent = /** @class */ (function () {\n            function OverrideComponent() {\n            }\n            OverrideComponent.decorators = [\n                { type: Component, args: [{ selector: 'empty', template: template },] },\n            ];\n            /** @nocollapse */\n            OverrideComponent.ctorParameters = function () { return []; };\n            return OverrideComponent;\n        }());\n        this._templateOverrides.push({ component: component, templateOf: OverrideComponent });\n    };\n    TestBed.prototype.createComponent = function (component) {\n        var _this = this;\n        this._initIfNeeded();\n        var componentFactory = this._compiler.getComponentFactory(component);\n        if (!componentFactory) {\n            throw new Error(\"Cannot create the component \" + stringify(component) + \" as it was not imported into the testing module!\");\n        }\n        var noNgZone = this.get(ComponentFixtureNoNgZone, false);\n        var autoDetect = this.get(ComponentFixtureAutoDetect, false);\n        var ngZone = noNgZone ? null : this.get(NgZone, null);\n        var testComponentRenderer = this.get(TestComponentRenderer);\n        var rootElId = \"root\" + _nextRootElementId++;\n        testComponentRenderer.insertRootElement(rootElId);\n        var initComponent = function () {\n            var componentRef = componentFactory.create(Injector.NULL, [], \"#\" + rootElId, _this._moduleRef);\n            return new ComponentFixture(componentRef, ngZone, autoDetect);\n        };\n        var fixture = !ngZone ? initComponent() : ngZone.run(initComponent);\n        this._activeFixtures.push(fixture);\n        return fixture;\n    };\n    return TestBed;\n}());\n/**\n * @description\n * Configures and initializes environment for unit testing and provides methods for\n * creating components and services in unit tests.\n *\n * TestBed is the primary api for writing unit tests for Angular applications and libraries.\n *\n *\n */\nexport { TestBed };\nvar _testBed = (null);\n/**\n * @experimental\n */\nexport function getTestBed() {\n    return _testBed = _testBed || new TestBed();\n}\n/**\n * Allows injecting dependencies in `beforeEach()` and `it()`.\n *\n * Example:\n *\n * ```\n * beforeEach(inject([Dependency, AClass], (dep, object) => {\n *   // some code that uses `dep` and `object`\n *   // ...\n * }));\n *\n * it('...', inject([AClass], (object) => {\n *   object.doSomething();\n *   expect(...);\n * })\n * ```\n *\n * Notes:\n * - inject is currently a function because of some Traceur limitation the syntax should\n * eventually\n *   becomes `it('...', @Inject (object: AClass, async: AsyncTestCompleter) => { ... });`\n *\n *\n */\nexport function inject(tokens, fn) {\n    var testBed = getTestBed();\n    if (tokens.indexOf(AsyncTestCompleter) >= 0) {\n        // Not using an arrow function to preserve context passed from call site\n        return function () {\n            var _this = this;\n            // Return an async test method that returns a Promise if AsyncTestCompleter is one of\n            // the injected tokens.\n            return testBed.compileComponents().then(function () {\n                var completer = testBed.get(AsyncTestCompleter);\n                testBed.execute(tokens, fn, _this);\n                return completer.promise;\n            });\n        };\n    }\n    else {\n        // Not using an arrow function to preserve context passed from call site\n        return function () { return testBed.execute(tokens, fn, this); };\n    }\n}\n/**\n * @experimental\n */\nvar /**\n * @experimental\n */\nInjectSetupWrapper = /** @class */ (function () {\n    function InjectSetupWrapper(_moduleDef) {\n        this._moduleDef = _moduleDef;\n    }\n    InjectSetupWrapper.prototype._addModule = function () {\n        var moduleDef = this._moduleDef();\n        if (moduleDef) {\n            getTestBed().configureTestingModule(moduleDef);\n        }\n    };\n    InjectSetupWrapper.prototype.inject = function (tokens, fn) {\n        var self = this;\n        // Not using an arrow function to preserve context passed from call site\n        return function () {\n            self._addModule();\n            return inject(tokens, fn).call(this);\n        };\n    };\n    return InjectSetupWrapper;\n}());\n/**\n * @experimental\n */\nexport { InjectSetupWrapper };\nexport function withModule(moduleDef, fn) {\n    if (fn) {\n        // Not using an arrow function to preserve context passed from call site\n        return function () {\n            var testBed = getTestBed();\n            if (moduleDef) {\n                testBed.configureTestingModule(moduleDef);\n            }\n            return fn.apply(this);\n        };\n    }\n    return new InjectSetupWrapper(function () { return moduleDef; });\n}\n//# sourceMappingURL=test_bed.js.map","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { resetFakeAsyncZone } from './fake_async';\nimport { TestBed } from './test_bed';\nvar _global = (typeof window === 'undefined' ? global : window);\n// Reset the test providers and the fake async zone before each test.\nif (_global.beforeEach) {\n    _global.beforeEach(function () {\n        TestBed.resetTestingModule();\n        resetFakeAsyncZone();\n    });\n}\n// TODO(juliemr): remove this, only used because we need to export something to have compilation\n// work.\nexport var __core_private_testing_placeholder__ = '';\n//# sourceMappingURL=before_each.js.map","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n* Wraps a function in a new function which sets up document and HTML for running a test.\n*\n* This function is intended to wrap an existing testing function. The wrapper\n* adds HTML to the `body` element of the `document` and subsequently tears it down.\n*\n* This function is intended to be used with `async await` and `Promise`s. If the wrapped\n* function returns a promise (or is `async`) then the teardown is delayed until that `Promise`\n* is resolved.\n*\n* On `node` this function detects if `document` is present and if not it will create one by\n* loading `domino` and installing it.\n*\n* Example:\n*\n* ```\n* describe('something', () => {\n*   it('should do something', withBody('<my-app></my-app>', async () => {\n*     const myApp = renderComponent(MyApp);\n*     await whenRendered(myApp);\n*     expect(getRenderedText(myApp)).toEqual('Hello World!');\n*   }));\n* });\n* ```\n*\n* @param html HTML which should be inserted into `body` of the `document`.\n* @param blockFn function to wrap. The function can return promise or be `async`.\n* @experimental\n*/\nexport function withBody(html, blockFn) {\n    return function (done) {\n        ensureDocument();\n        var returnValue = undefined;\n        if (typeof blockFn === 'function') {\n            document.body.innerHTML = html;\n            // TODO(i): I'm not sure why a cast is required here but otherwise I get\n            //   TS2349: Cannot invoke an expression whose type lacks a call signature. Type 'never' has\n            //   no compatible call signatures.\n            var blockReturn = blockFn();\n            if (blockReturn instanceof Promise) {\n                blockReturn = blockReturn.then(done, done.fail);\n            }\n            else {\n                done();\n            }\n        }\n    };\n}\nvar savedDocument = undefined;\nvar savedRequestAnimationFrame = undefined;\nvar savedNode = undefined;\nvar requestAnimationFrameCount = 0;\nvar ɵ0 = function (domino) {\n    if (typeof global == 'object' && global.process && typeof require == 'function') {\n        try {\n            return require(domino);\n        }\n        catch (e) {\n            // It is possible that we don't have domino available in which case just give up.\n        }\n    }\n    // Seems like we don't have domino, give up.\n    return null;\n};\n/**\n * System.js uses regexp to look for `require` statements. `domino` has to be\n * extracted into a constant so that the regexp in the System.js does not match\n * and does not try to load domino in the browser.\n */\nvar domino = (ɵ0)('domino');\n/**\n * Ensure that global has `Document` if we are in node.js\n * @experimental\n */\nexport function ensureDocument() {\n    if (domino) {\n        // we are in node.js.\n        var window_1 = domino.createWindow('', 'http://localhost');\n        savedDocument = global.document;\n        global.window = window_1;\n        global.document = window_1.document;\n        // Trick to avoid Event patching from\n        // https://github.com/angular/angular/blob/7cf5e95ac9f0f2648beebf0d5bd9056b79946970/packages/platform-browser/src/dom/events/dom_events.ts#L112-L132\n        // It fails with Domino with TypeError: Cannot assign to read only property\n        // 'stopImmediatePropagation' of object '#<Event>'\n        // Trick to avoid Event patching from\n        // https://github.com/angular/angular/blob/7cf5e95ac9f0f2648beebf0d5bd9056b79946970/packages/platform-browser/src/dom/events/dom_events.ts#L112-L132\n        // It fails with Domino with TypeError: Cannot assign to read only property\n        // 'stopImmediatePropagation' of object '#<Event>'\n        global.Event = null;\n        savedNode = global.Node;\n        global.Node = domino.impl.Node;\n        savedRequestAnimationFrame = global.requestAnimationFrame;\n        global.requestAnimationFrame = function (cb) {\n            setImmediate(cb);\n            return requestAnimationFrameCount++;\n        };\n    }\n}\n/**\n * Restore the state of `Document` between tests.\n * @experimental\n */\nexport function cleanupDocument() {\n    if (savedDocument) {\n        global.document = savedDocument;\n        global.window = undefined;\n        savedDocument = undefined;\n    }\n    if (savedNode) {\n        global.Node = savedNode;\n        savedNode = undefined;\n    }\n    if (savedRequestAnimationFrame) {\n        global.requestAnimationFrame = savedRequestAnimationFrame;\n        savedRequestAnimationFrame = undefined;\n    }\n}\nif (typeof beforeEach == 'function')\n    beforeEach(ensureDocument);\nif (typeof afterEach == 'function')\n    beforeEach(cleanupDocument);\nexport { ɵ0 };\n//# sourceMappingURL=render3.js.map","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { asyncFallback } from './async_fallback';\n/**\n * Wraps a test function in an asynchronous test zone. The test will automatically\n * complete when all asynchronous calls within this zone are done. Can be used\n * to wrap an {@link inject} call.\n *\n * Example:\n *\n * ```\n * it('...', async(inject([AClass], (object) => {\n *   object.doSomething.then(() => {\n *     expect(...);\n *   })\n * });\n * ```\n *\n *\n */\nexport function async(fn) {\n    var _Zone = typeof Zone !== 'undefined' ? Zone : null;\n    if (!_Zone) {\n        return function () {\n            return Promise.reject('Zone is needed for the async() test helper but could not be found. ' +\n                'Please make sure that your environment includes zone.js/dist/zone.js');\n        };\n    }\n    var asyncTest = _Zone && _Zone[_Zone.__symbol__('asyncTest')];\n    if (typeof asyncTest === 'function') {\n        return asyncTest(fn);\n    }\n    // not using new version of zone.js\n    // TODO @JiaLiPassion, remove this after all library updated to\n    // newest version of zone.js(0.8.25)\n    return asyncFallback(fn);\n}\n//# sourceMappingURL=async.js.map"]}