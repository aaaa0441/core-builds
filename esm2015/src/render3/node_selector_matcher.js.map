{"version":3,"file":"node_selector_matcher.js","sourceRoot":"","sources":["../../../../../packages/core/src/render3/node_selector_matcher.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport './ng_dev_mode';\n\nimport {assertNotNull} from './assert';\nimport {TNode, unusedValueExportToPlacateAjd as unused1} from './interfaces/node';\nimport {CssSelector, CssSelectorList, NG_PROJECT_AS_ATTR_NAME, SelectorFlags, unusedValueExportToPlacateAjd as unused2} from './interfaces/projection';\n\nconst unusedValueToPlacateAjd = unused1 + unused2;\n\nfunction isCssClassMatching(nodeClassAttrVal: string, cssClassToMatch: string): boolean {\n  const nodeClassesLen = nodeClassAttrVal.length;\n  const matchIndex = nodeClassAttrVal !.indexOf(cssClassToMatch);\n  const matchEndIdx = matchIndex + cssClassToMatch.length;\n  if (matchIndex === -1                                                  // no match\n      || (matchIndex > 0 && nodeClassAttrVal ![matchIndex - 1] !== ' ')  // no space before\n      ||\n      (matchEndIdx < nodeClassesLen && nodeClassAttrVal ![matchEndIdx] !== ' '))  // no space after\n  {\n    return false;\n  }\n  return true;\n}\n\n/**\n * A utility function to match an Ivy node static data against a simple CSS selector\n *\n * @param node static data to match\n * @param selector\n * @returns true if node matches the selector.\n */\nexport function isNodeMatchingSelector(tNode: TNode, selector: CssSelector): boolean {\n  ngDevMode && assertNotNull(selector[0], 'Selector should have a tag name');\n\n  let mode: SelectorFlags = SelectorFlags.ELEMENT;\n  const nodeAttrs = tNode.attrs !;\n\n  // When processing \":not\" selectors, we skip to the next \":not\" if the\n  // current one doesn't match\n  let skipToNextSelector = false;\n\n  for (let i = 0; i < selector.length; i++) {\n    const current = selector[i];\n    if (typeof current === 'number') {\n      // If we finish processing a :not selector and it hasn't failed, return false\n      if (!skipToNextSelector && !isPositive(mode) && !isPositive(current as number)) {\n        return false;\n      }\n      // If we are skipping to the next :not() and this mode flag is positive,\n      // it's a part of the current :not() selector, and we should keep skipping\n      if (skipToNextSelector && isPositive(current)) continue;\n      skipToNextSelector = false;\n      mode = (current as number) | (mode & SelectorFlags.NOT);\n      continue;\n    }\n\n    if (skipToNextSelector) continue;\n\n    if (mode & SelectorFlags.ELEMENT) {\n      mode = SelectorFlags.ATTRIBUTE | mode & SelectorFlags.NOT;\n      if (current !== '' && current !== tNode.tagName) {\n        if (isPositive(mode)) return false;\n        skipToNextSelector = true;\n      }\n    } else {\n      const attrName = mode & SelectorFlags.CLASS ? 'class' : current;\n      const attrIndexInNode = findAttrIndexInNode(attrName, nodeAttrs);\n\n      if (attrIndexInNode === -1) {\n        if (isPositive(mode)) return false;\n        skipToNextSelector = true;\n        continue;\n      }\n\n      const selectorAttrValue = mode & SelectorFlags.CLASS ? current : selector[++i];\n      if (selectorAttrValue !== '') {\n        const nodeAttrValue = nodeAttrs[attrIndexInNode + 1];\n        if (mode & SelectorFlags.CLASS &&\n                !isCssClassMatching(nodeAttrValue, selectorAttrValue as string) ||\n            mode & SelectorFlags.ATTRIBUTE && selectorAttrValue !== nodeAttrValue) {\n          if (isPositive(mode)) return false;\n          skipToNextSelector = true;\n        }\n      }\n    }\n  }\n\n  return isPositive(mode) || skipToNextSelector;\n}\n\nfunction isPositive(mode: SelectorFlags): boolean {\n  return (mode & SelectorFlags.NOT) === 0;\n}\n\nfunction findAttrIndexInNode(name: string, attrs: string[] | null): number {\n  if (attrs === null) return -1;\n  for (let i = 0; i < attrs.length; i += 2) {\n    if (attrs[i] === name) return i;\n  }\n  return -1;\n}\n\nexport function isNodeMatchingSelectorList(tNode: TNode, selector: CssSelectorList): boolean {\n  for (let i = 0; i < selector.length; i++) {\n    if (isNodeMatchingSelector(tNode, selector[i])) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nexport function getProjectAsAttrValue(tNode: TNode): string|null {\n  const nodeAttrs = tNode.attrs;\n  if (nodeAttrs != null) {\n    const ngProjectAsAttrIdx = nodeAttrs.indexOf(NG_PROJECT_AS_ATTR_NAME);\n    // only check for ngProjectAs in attribute names, don't accidentally match attribute's value\n    // (attribute names are stored at even indexes)\n    if ((ngProjectAsAttrIdx & 1) === 0) {\n      return nodeAttrs[ngProjectAsAttrIdx + 1];\n    }\n  }\n  return null;\n}\n\n/**\n * Checks a given node against matching selectors and returns\n * selector index (or 0 if none matched).\n *\n * This function takes into account the ngProjectAs attribute: if present its value will be compared\n * to the raw (un-parsed) CSS selector instead of using standard selector matching logic.\n */\nexport function matchingSelectorIndex(\n    tNode: TNode, selectors: CssSelectorList[], textSelectors: string[]): number {\n  const ngProjectAsAttrVal = getProjectAsAttrValue(tNode);\n  for (let i = 0; i < selectors.length; i++) {\n    // if a node has the ngProjectAs attribute match it against unparsed selector\n    // match a node against a parsed selector only if ngProjectAs attribute is not present\n    if (ngProjectAsAttrVal === textSelectors[i] ||\n        ngProjectAsAttrVal === null && isNodeMatchingSelectorList(tNode, selectors[i])) {\n      return i + 1;  // first matching selector \"captures\" a given node\n    }\n  }\n  return 0;\n}\n"]}