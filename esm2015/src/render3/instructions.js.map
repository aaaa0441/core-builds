{"version":3,"file":"instructions.js","sourceRoot":"","sources":["../../../../../packages/core/src/render3/instructions.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport './ng_dev_mode';\n\nimport {assertEqual, assertLessThan, assertNotEqual, assertNotNull, assertNull, assertSame} from './assert';\nimport {LContainer, TContainer} from './interfaces/container';\nimport {LInjector} from './interfaces/injector';\nimport {CssSelectorList, LProjection, NG_PROJECT_AS_ATTR_NAME} from './interfaces/projection';\nimport {LQueries} from './interfaces/query';\nimport {CurrentMatchesList, LView, LViewFlags, LifecycleStage, RootContext, TData, TView} from './interfaces/view';\n\nimport {LContainerNode, LElementNode, LNode, LNodeType, TNodeFlags, LProjectionNode, LTextNode, LViewNode, TNode, TContainerNode, InitialInputData, InitialInputs, PropertyAliases, PropertyAliasValue,} from './interfaces/node';\nimport {assertNodeType} from './node_assert';\nimport {appendChild, insertView, appendProjectedNode, removeView, canInsertNativeNode, createTextNode} from './node_manipulation';\nimport {isNodeMatchingSelectorList, matchingSelectorIndex} from './node_selector_matcher';\nimport {ComponentDef, ComponentTemplate, DirectiveDef, DirectiveDefList, DirectiveDefListOrFactory, PipeDefList, PipeDefListOrFactory, RenderFlags} from './interfaces/definition';\nimport {RElement, RText, Renderer3, RendererFactory3, ProceduralRenderer3, RendererStyleFlags3, isProceduralRenderer} from './interfaces/renderer';\nimport {isDifferent, stringify} from './util';\nimport {executeHooks, queueLifecycleHooks, queueInitHooks, executeInitHooks} from './hooks';\nimport {ViewRef} from './view_ref';\nimport {throwCyclicDependencyError, throwErrorIfNoChangesMode, throwMultipleComponentError} from './errors';\n\n/**\n * Directive (D) sets a property on all component instances using this constant as a key and the\n * component's host node (LElement) as the value. This is used in methods like detectChanges to\n * facilitate jumping from an instance to the host node.\n */\nexport const NG_HOST_SYMBOL = '__ngHostLNode__';\n\n/**\n * A permanent marker promise which signifies that the current CD tree is\n * clean.\n */\nconst _CLEAN_PROMISE = Promise.resolve(null);\n\n/**\n * Function used to sanitize the value before writing it into the renderer.\n */\nexport type Sanitizer = (value: any) => string;\n\n/**\n * Directive and element indices for top-level directive.\n *\n * Saved here to avoid re-instantiating an array on every change detection run.\n */\nexport const _ROOT_DIRECTIVE_INDICES = [0, 0];\n\n/**\n * Token set in currentMatches while dependencies are being resolved.\n *\n * If we visit a directive that has a value set to CIRCULAR, we know we've\n * already seen it, and thus have a circular dependency.\n */\nexport const CIRCULAR = '__CIRCULAR__';\n\n/**\n * This property gets set before entering a template.\n *\n * This renderer can be one of two varieties of Renderer3:\n *\n * - ObjectedOrientedRenderer3\n *\n * This is the native browser API style, e.g. operations are methods on individual objects\n * like HTMLElement. With this style, no additional code is needed as a facade (reducing payload\n * size).\n *\n * - ProceduralRenderer3\n *\n * In non-native browser environments (e.g. platforms such as web-workers), this is the facade\n * that enables element manipulation. This also facilitates backwards compatibility with\n * Renderer2.\n */\nlet renderer: Renderer3;\nlet rendererFactory: RendererFactory3;\n\nexport function getRenderer(): Renderer3 {\n  // top level variables should not be exported for performance reason (PERF_NOTES.md)\n  return renderer;\n}\n\n/** Used to set the parent property when nodes are created. */\nlet previousOrParentNode: LNode;\n\nexport function getPreviousOrParentNode(): LNode {\n  // top level variables should not be exported for performance reason (PERF_NOTES.md)\n  return previousOrParentNode;\n}\n\n/**\n * If `isParent` is:\n *  - `true`: then `previousOrParentNode` points to a parent node.\n *  - `false`: then `previousOrParentNode` points to previous node (sibling).\n */\nlet isParent: boolean;\n\n/**\n * Static data that corresponds to the instance-specific data array on an LView.\n *\n * Each node's static data is stored in tData at the same index that it's stored\n * in the data array. Any nodes that do not have static data store a null value in\n * tData to avoid a sparse array.\n */\nlet tData: TData;\n\n/**\n * State of the current view being processed.\n *\n * NOTE: we cheat here and initialize it to `null` even thought the type does not\n * contain `null`. This is because we expect this value to be not `null` as soon\n * as we enter the view. Declaring the type as `null` would require us to place `!`\n * in most instructions since they all assume that `currentView` is defined.\n */\nlet currentView: LView = null !;\n\nlet currentQueries: LQueries|null;\n\nexport function getCurrentQueries(QueryType: {new (): LQueries}): LQueries {\n  // top level variables should not be exported for performance reason (PERF_NOTES.md)\n  return currentQueries || (currentQueries = new QueryType());\n}\n\n/**\n * This property gets set before entering a template.\n */\nlet creationMode: boolean;\n\nexport function getCreationMode(): boolean {\n  // top level variables should not be exported for performance reason (PERF_NOTES.md)\n  return creationMode;\n}\n\n/**\n * An array of nodes (text, element, container, etc), pipes, their bindings, and\n * any local variables that need to be stored between invocations.\n */\nlet data: any[];\n\n/**\n * An array of directive instances in the current view.\n *\n * These must be stored separately from LNodes because their presence is\n * unknown at compile-time and thus space cannot be reserved in data[].\n */\nlet directives: any[]|null;\n\n/**\n * When a view is destroyed, listeners need to be released and outputs need to be\n * unsubscribed. This cleanup array stores both listener data (in chunks of 4)\n * and output data (in chunks of 2) for a particular view. Combining the arrays\n * saves on memory (70 bytes per array) and on a few bytes of code size (for two\n * separate for loops).\n *\n * If it's a listener being stored:\n * 1st index is: event name to remove\n * 2nd index is: native element\n * 3rd index is: listener function\n * 4th index is: useCapture boolean\n *\n * If it's an output subscription:\n * 1st index is: unsubscribe function\n * 2nd index is: context for function\n */\nlet cleanup: any[]|null;\n\n/**\n * In this mode, any changes in bindings will throw an ExpressionChangedAfterChecked error.\n *\n * Necessary to support ChangeDetectorRef.checkNoChanges().\n */\nlet checkNoChangesMode = false;\n\n/** Whether or not this is the first time the current view has been processed. */\nlet firstTemplatePass = true;\n\nconst enum BindingDirection {\n  Input,\n  Output,\n}\n\n/**\n * Swap the current state with a new state.\n *\n * For performance reasons we store the state in the top level of the module.\n * This way we minimize the number of properties to read. Whenever a new view\n * is entered we have to store the state for later, and when the view is\n * exited the state has to be restored\n *\n * @param newView New state to become active\n * @param host Element to which the View is a child of\n * @returns the previous state;\n */\nexport function enterView(newView: LView, host: LElementNode | LViewNode | null): LView {\n  const oldView: LView = currentView;\n  data = newView && newView.data;\n  directives = newView && newView.directives;\n  tData = newView && newView.tView.data;\n  creationMode = newView && (newView.flags & LViewFlags.CreationMode) === LViewFlags.CreationMode;\n  firstTemplatePass = newView && newView.tView.firstTemplatePass;\n\n  cleanup = newView && newView.cleanup;\n  renderer = newView && newView.renderer;\n\n  if (newView && newView.bindingIndex < 0) {\n    newView.bindingIndex = newView.bindingStartIndex;\n  }\n\n  if (host != null) {\n    previousOrParentNode = host;\n    isParent = true;\n  }\n\n  currentView = newView;\n  currentQueries = newView && newView.queries;\n\n  return oldView;\n}\n\n/**\n * Used in lieu of enterView to make it clear when we are exiting a child view. This makes\n * the direction of traversal (up or down the view tree) a bit clearer.\n *\n * @param newView New state to become active\n * @param creationOnly An optional boolean to indicate that the view was processed in creation mode\n * only, i.e. the first update will be done later. Only possible for dynamically created views.\n */\nexport function leaveView(newView: LView, creationOnly?: boolean): void {\n  if (!creationOnly) {\n    if (!checkNoChangesMode) {\n      executeHooks(\n          directives !, currentView.tView.viewHooks, currentView.tView.viewCheckHooks,\n          creationMode);\n    }\n    // Views are clean and in update mode after being checked, so these bits are cleared\n    currentView.flags &= ~(LViewFlags.CreationMode | LViewFlags.Dirty);\n  }\n  currentView.lifecycleStage = LifecycleStage.Init;\n  currentView.bindingIndex = -1;\n  enterView(newView, null);\n}\n\n/**\n * Refreshes the view, executing the following steps in that order:\n * triggers init hooks, refreshes dynamic children, triggers content hooks, sets host bindings,\n * refreshes child components.\n * Note: view hooks are triggered later when leaving the view.\n * */\nfunction refreshView() {\n  const tView = currentView.tView;\n  if (!checkNoChangesMode) {\n    executeInitHooks(currentView, tView, creationMode);\n  }\n  refreshDynamicChildren();\n  if (!checkNoChangesMode) {\n    executeHooks(directives !, tView.contentHooks, tView.contentCheckHooks, creationMode);\n  }\n\n  // This needs to be set before children are processed to support recursive components\n  tView.firstTemplatePass = firstTemplatePass = false;\n\n  setHostBindings(tView.hostBindings);\n  refreshChildComponents(tView.components);\n}\n\n/** Sets the host bindings for the current view. */\nexport function setHostBindings(bindings: number[] | null): void {\n  if (bindings != null) {\n    const defs = currentView.tView.directives !;\n    for (let i = 0; i < bindings.length; i += 2) {\n      const dirIndex = bindings[i];\n      const def = defs[dirIndex] as DirectiveDef<any>;\n      def.hostBindings && def.hostBindings(dirIndex, bindings[i + 1]);\n    }\n  }\n}\n\n/** Refreshes child components in the current view. */\nfunction refreshChildComponents(components: number[] | null): void {\n  if (components != null) {\n    for (let i = 0; i < components.length; i += 2) {\n      componentRefresh(components[i], components[i + 1]);\n    }\n  }\n}\n\nexport function executeInitAndContentHooks(): void {\n  if (!checkNoChangesMode) {\n    const tView = currentView.tView;\n    executeInitHooks(currentView, tView, creationMode);\n    executeHooks(directives !, tView.contentHooks, tView.contentCheckHooks, creationMode);\n  }\n}\n\nexport function createLView<T>(\n    viewId: number, renderer: Renderer3, tView: TView, template: ComponentTemplate<T>| null,\n    context: T | null, flags: LViewFlags): LView {\n  const newView = {\n    parent: currentView,\n    id: viewId,  // -1 for component views\n    flags: flags | LViewFlags.CreationMode | LViewFlags.Attached,\n    node: null !,  // until we initialize it in createNode.\n    data: [],\n    directives: null,\n    tView: tView,\n    cleanup: null,\n    renderer: renderer,\n    child: null,\n    tail: null,\n    next: null,\n    bindingStartIndex: -1,\n    bindingIndex: -1,\n    template: template,\n    context: context,\n    dynamicViewCount: 0,\n    lifecycleStage: LifecycleStage.Init,\n    queries: null,\n    injector: currentView && currentView.injector,\n  };\n\n  return newView;\n}\n\n/**\n * Creation of LNode object is extracted to a separate function so we always create LNode object\n * with the same shape\n * (same properties assigned in the same order).\n */\nexport function createLNodeObject(\n    type: LNodeType, currentView: LView, parent: LNode, native: RText | RElement | null | undefined,\n    state: any,\n    queries: LQueries | null): LElementNode&LTextNode&LViewNode&LContainerNode&LProjectionNode {\n  return {\n    type: type,\n    native: native as any,\n    view: currentView,\n    parent: parent as any,\n    child: null,\n    next: null,\n    nodeInjector: parent ? parent.nodeInjector : null,\n    data: state,\n    queries: queries,\n    tNode: null,\n    pNextOrParent: null,\n    dynamicLContainerNode: null\n  };\n}\n\n/**\n * A common way of creating the LNode to make sure that all of them have same shape to\n * keep the execution code monomorphic and fast.\n */\nexport function createLNode(\n    index: number | null, type: LNodeType.Element, native: RElement | RText | null,\n    lView?: LView | null): LElementNode;\nexport function createLNode(\n    index: null, type: LNodeType.View, native: null, lView: LView): LViewNode;\nexport function createLNode(\n    index: number, type: LNodeType.Container, native: undefined,\n    lContainer: LContainer): LContainerNode;\nexport function createLNode(\n    index: number, type: LNodeType.Projection, native: null,\n    lProjection: LProjection): LProjectionNode;\nexport function createLNode(\n    index: number | null, type: LNodeType, native: RText | RElement | null | undefined,\n    state?: null | LView | LContainer | LProjection): LElementNode&LTextNode&LViewNode&\n    LContainerNode&LProjectionNode {\n  const parent = isParent ? previousOrParentNode :\n                            previousOrParentNode && previousOrParentNode.parent as LNode;\n  let queries =\n      (isParent ? currentQueries : previousOrParentNode && previousOrParentNode.queries) ||\n      parent && parent.queries && parent.queries.child();\n  const isState = state != null;\n  const node =\n      createLNodeObject(type, currentView, parent, native, isState ? state as any : null, queries);\n\n  if ((type & LNodeType.ViewOrElement) === LNodeType.ViewOrElement && isState) {\n    // Bit of a hack to bust through the readonly because there is a circular dep between\n    // LView and LNode.\n    ngDevMode && assertNull((state as LView).node, 'LView.node should not have been initialized');\n    (state as LView as{node: LNode}).node = node;\n  }\n  if (index != null) {\n    // We are Element or Container\n    ngDevMode && assertDataNext(index);\n    data[index] = node;\n\n    // Every node adds a value to the static data array to avoid a sparse array\n    if (index >= tData.length) {\n      tData[index] = null;\n    } else {\n      node.tNode = tData[index] as TNode;\n    }\n\n    // Now link ourselves into the tree.\n    if (isParent) {\n      currentQueries = null;\n      if (previousOrParentNode.view === currentView ||\n          previousOrParentNode.type === LNodeType.View) {\n        // We are in the same view, which means we are adding content node to the parent View.\n        ngDevMode && assertNull(\n                         previousOrParentNode.child,\n                         `previousOrParentNode's child should not have been set.`);\n        previousOrParentNode.child = node;\n      } else {\n        // We are adding component view, so we don't link parent node child to this node.\n      }\n    } else if (previousOrParentNode) {\n      ngDevMode && assertNull(\n                       previousOrParentNode.next,\n                       `previousOrParentNode's next property should not have been set ${index}.`);\n      previousOrParentNode.next = node;\n      if (previousOrParentNode.dynamicLContainerNode) {\n        previousOrParentNode.dynamicLContainerNode.next = node;\n      }\n    }\n  }\n  previousOrParentNode = node;\n  isParent = true;\n  return node;\n}\n\n\n//////////////////////////\n//// Render\n//////////////////////////\n\n/**\n * Resets the application state.\n */\nfunction resetApplicationState() {\n  isParent = false;\n  previousOrParentNode = null !;\n}\n\n/**\n *\n * @param hostNode Existing node to render into.\n * @param template Template function with the instructions.\n * @param context to pass into the template.\n * @param providedRendererFactory renderer factory to use\n * @param host The host element node to use\n * @param directives Directive defs that should be used for matching\n * @param pipes Pipe defs that should be used for matching\n */\nexport function renderTemplate<T>(\n    hostNode: RElement, template: ComponentTemplate<T>, context: T,\n    providedRendererFactory: RendererFactory3, host: LElementNode | null,\n    directives?: DirectiveDefListOrFactory | null,\n    pipes?: PipeDefListOrFactory | null): LElementNode {\n  if (host == null) {\n    resetApplicationState();\n    rendererFactory = providedRendererFactory;\n    const tView = getOrCreateTView(template, directives || null, pipes || null);\n    host = createLNode(\n        null, LNodeType.Element, hostNode,\n        createLView(\n            -1, providedRendererFactory.createRenderer(null, null), tView, null, {},\n            LViewFlags.CheckAlways));\n  }\n  const hostView = host.data !;\n  ngDevMode && assertNotNull(hostView, 'Host node should have an LView defined in host.data.');\n  renderComponentOrTemplate(host, hostView, context, template);\n  return host;\n}\n\nexport function renderEmbeddedTemplate<T>(\n    viewNode: LViewNode | null, template: ComponentTemplate<T>, context: T, renderer: Renderer3,\n    directives?: DirectiveDefList | null, pipes?: PipeDefList | null): LViewNode {\n  const _isParent = isParent;\n  const _previousOrParentNode = previousOrParentNode;\n  let oldView: LView;\n  let rf: RenderFlags = RenderFlags.Update;\n  try {\n    isParent = true;\n    previousOrParentNode = null !;\n\n    if (viewNode == null) {\n      const tView = getOrCreateTView(template, directives || null, pipes || null);\n      const lView = createLView(-1, renderer, tView, template, context, LViewFlags.CheckAlways);\n\n      viewNode = createLNode(null, LNodeType.View, null, lView);\n      rf = RenderFlags.Create;\n    }\n    oldView = enterView(viewNode.data, viewNode);\n    template(rf, context);\n    if (rf & RenderFlags.Update) {\n      refreshView();\n    } else {\n      viewNode.data.tView.firstTemplatePass = firstTemplatePass = false;\n    }\n  } finally {\n    // renderEmbeddedTemplate() is called twice in fact, once for creation only and then once for\n    // update. When for creation only, leaveView() must not trigger view hooks, nor clean flags.\n    const isCreationOnly = (rf & RenderFlags.Create) === RenderFlags.Create;\n    leaveView(oldView !, isCreationOnly);\n    isParent = _isParent;\n    previousOrParentNode = _previousOrParentNode;\n  }\n  return viewNode;\n}\n\nexport function renderComponentOrTemplate<T>(\n    node: LElementNode, hostView: LView, componentOrContext: T, template?: ComponentTemplate<T>) {\n  const oldView = enterView(hostView, node);\n  try {\n    if (rendererFactory.begin) {\n      rendererFactory.begin();\n    }\n    if (template) {\n      template(getRenderFlags(hostView), componentOrContext !);\n      refreshView();\n    } else {\n      executeInitAndContentHooks();\n\n      // Element was stored at 0 in data and directive was stored at 0 in directives\n      // in renderComponent()\n      setHostBindings(_ROOT_DIRECTIVE_INDICES);\n      componentRefresh(0, 0);\n    }\n  } finally {\n    if (rendererFactory.end) {\n      rendererFactory.end();\n    }\n    leaveView(oldView);\n  }\n}\n\n/**\n * This function returns the default configuration of rendering flags depending on when the\n * template is in creation mode or update mode. By default, the update block is run with the\n * creation block when the view is in creation mode. Otherwise, the update block is run\n * alone.\n *\n * Dynamically created views do NOT use this configuration (update block and create block are\n * always run separately).\n */\nfunction getRenderFlags(view: LView): RenderFlags {\n  return view.flags & LViewFlags.CreationMode ? RenderFlags.Create | RenderFlags.Update :\n                                                RenderFlags.Update;\n}\n\n//////////////////////////\n//// Element\n//////////////////////////\n\n/**\n * Create DOM element. The instruction must later be followed by `elementEnd()` call.\n *\n * @param index Index of the element in the data array\n * @param name Name of the DOM Node\n * @param attrs Statically bound set of attributes to be written into the DOM element on creation.\n * @param localRefs A set of local reference bindings on the element.\n *\n * Attributes and localRefs are passed as an array of strings where elements with an even index\n * hold an attribute name and elements with an odd index hold an attribute value, ex.:\n * ['id', 'warning5', 'class', 'alert']\n */\nexport function elementStart(\n    index: number, name: string, attrs?: string[] | null, localRefs?: string[] | null): RElement {\n  ngDevMode &&\n      assertEqual(\n          currentView.bindingStartIndex, -1, 'elements should be created before any bindings');\n\n  const native: RElement = renderer.createElement(name);\n  const node: LElementNode = createLNode(index, LNodeType.Element, native !, null);\n\n  if (attrs) setUpAttributes(native, attrs);\n  appendChild(node.parent !, native, currentView);\n  createDirectivesAndLocals(index, name, attrs, localRefs, null);\n  return native;\n}\n\nfunction createDirectivesAndLocals(\n    index: number, name: string | null, attrs: string[] | null | undefined,\n    localRefs: string[] | null | undefined, containerData: TView[] | null) {\n  const node = previousOrParentNode;\n  if (firstTemplatePass) {\n    ngDevMode && assertDataInRange(index - 1);\n    node.tNode = tData[index] = createTNode(name, attrs || null, containerData);\n    cacheMatchingDirectivesForNode(node.tNode, currentView.tView, localRefs || null);\n  } else {\n    instantiateDirectivesDirectly();\n  }\n  saveResolvedLocalsInData();\n}\n\n/**\n * On first template pass, we match each node against available directive selectors and save\n * the resulting defs in the correct instantiation order for subsequent change detection runs\n * (so dependencies are always created before the directives that inject them).\n */\nfunction cacheMatchingDirectivesForNode(\n    tNode: TNode, tView: TView, localRefs: string[] | null): void {\n  // Please make sure to have explicit type for `exportsMap`. Inferred type triggers bug in tsickle.\n  const exportsMap: ({[key: string]: number} | null) = localRefs ? {'': -1} : null;\n  const matches = tView.currentMatches = findDirectiveMatches(tNode);\n  if (matches) {\n    for (let i = 0; i < matches.length; i += 2) {\n      const def = matches[i] as DirectiveDef<any>;\n      const valueIndex = i + 1;\n      resolveDirective(def, valueIndex, matches, tView);\n      saveNameToExportMap(matches[valueIndex] as number, def, exportsMap);\n    }\n  }\n  if (exportsMap) cacheMatchingLocalNames(tNode, localRefs, exportsMap);\n}\n\n/** Matches the current node against all available selectors. */\nfunction findDirectiveMatches(tNode: TNode): CurrentMatchesList|null {\n  const registry = currentView.tView.directiveRegistry;\n  let matches: any[]|null = null;\n  if (registry) {\n    for (let i = 0; i < registry.length; i++) {\n      const def = registry[i];\n      if (isNodeMatchingSelectorList(tNode, def.selectors !)) {\n        if ((def as ComponentDef<any>).template) {\n          if (tNode.flags & TNodeFlags.isComponent) throwMultipleComponentError(tNode);\n          tNode.flags = TNodeFlags.isComponent;\n        }\n        if (def.diPublic) def.diPublic(def);\n        (matches || (matches = [])).push(def, null);\n      }\n    }\n  }\n  return matches as CurrentMatchesList;\n}\n\nexport function resolveDirective(\n    def: DirectiveDef<any>, valueIndex: number, matches: CurrentMatchesList, tView: TView): any {\n  if (matches[valueIndex] === null) {\n    matches[valueIndex] = CIRCULAR;\n    const instance = def.factory();\n    (tView.directives || (tView.directives = [])).push(def);\n    return directiveCreate(matches[valueIndex] = tView.directives !.length - 1, instance, def);\n  } else if (matches[valueIndex] === CIRCULAR) {\n    // If we revisit this directive before it's resolved, we know it's circular\n    throwCyclicDependencyError(def.type);\n  }\n  return null;\n}\n\n/** Stores index of component's host element so it will be queued for view refresh during CD. */\nfunction queueComponentIndexForCheck(dirIndex: number): void {\n  if (firstTemplatePass) {\n    (currentView.tView.components || (currentView.tView.components = [\n     ])).push(dirIndex, data.length - 1);\n  }\n}\n\n/** Stores index of directive and host element so it will be queued for binding refresh during CD.\n */\nfunction queueHostBindingForCheck(dirIndex: number): void {\n  ngDevMode &&\n      assertEqual(firstTemplatePass, true, 'Should only be called in first template pass.');\n  (currentView.tView.hostBindings || (currentView.tView.hostBindings = [\n   ])).push(dirIndex, data.length - 1);\n}\n\n/** Sets the context for a ChangeDetectorRef to the given instance. */\nexport function initChangeDetectorIfExisting(\n    injector: LInjector | null, instance: any, view: LView): void {\n  if (injector && injector.changeDetectorRef != null) {\n    (injector.changeDetectorRef as ViewRef<any>)._setComponentContext(view, instance);\n  }\n}\n\nexport function isComponent(tNode: TNode): boolean {\n  return (tNode.flags & TNodeFlags.isComponent) === TNodeFlags.isComponent;\n}\n\n/**\n * This function instantiates the given directives.\n */\nfunction instantiateDirectivesDirectly() {\n  const tNode = previousOrParentNode.tNode !;\n  const count = tNode.flags & TNodeFlags.DirectiveCountMask;\n\n  if (count > 0) {\n    const start = tNode.flags >> TNodeFlags.DirectiveStartingIndexShift;\n    const end = start + count;\n    const tDirectives = currentView.tView.directives !;\n\n    for (let i = start; i < end; i++) {\n      const def: DirectiveDef<any> = tDirectives[i];\n      directiveCreate(i, def.factory(), def);\n    }\n  }\n}\n\n/** Caches local names and their matching directive indices for query and template lookups. */\nfunction cacheMatchingLocalNames(\n    tNode: TNode, localRefs: string[] | null, exportsMap: {[key: string]: number}): void {\n  if (localRefs) {\n    const localNames: (string | number)[] = tNode.localNames = [];\n\n    // Local names must be stored in tNode in the same order that localRefs are defined\n    // in the template to ensure the data is loaded in the same slots as their refs\n    // in the template (for template queries).\n    for (let i = 0; i < localRefs.length; i += 2) {\n      const index = exportsMap[localRefs[i + 1]];\n      if (index == null) throw new Error(`Export of name '${localRefs[i + 1]}' not found!`);\n      localNames.push(localRefs[i], index);\n    }\n  }\n}\n\n/**\n * Builds up an export map as directives are created, so local refs can be quickly mapped\n * to their directive instances.\n */\nfunction saveNameToExportMap(\n    index: number, def: DirectiveDef<any>| ComponentDef<any>,\n    exportsMap: {[key: string]: number} | null) {\n  if (exportsMap) {\n    if (def.exportAs) exportsMap[def.exportAs] = index;\n    if ((def as ComponentDef<any>).template) exportsMap[''] = index;\n  }\n}\n\n/**\n * Takes a list of local names and indices and pushes the resolved local variable values\n * to data[] in the same order as they are loaded in the template with load().\n */\nfunction saveResolvedLocalsInData(): void {\n  const localNames = previousOrParentNode.tNode !.localNames;\n  if (localNames) {\n    for (let i = 0; i < localNames.length; i += 2) {\n      const index = localNames[i + 1] as number;\n      const value = index === -1 ? previousOrParentNode.native : directives ![index];\n      data.push(value);\n    }\n  }\n}\n\n/**\n * Gets TView from a template function or creates a new TView\n * if it doesn't already exist.\n *\n * @param template The template from which to get static data\n * @param directives Directive defs that should be saved on TView\n * @param pipes Pipe defs that should be saved on TView\n * @returns TView\n */\nfunction getOrCreateTView(\n    template: ComponentTemplate<any>, directives: DirectiveDefListOrFactory | null,\n    pipes: PipeDefListOrFactory | null): TView {\n  return template.ngPrivateData ||\n      (template.ngPrivateData = createTView(directives, pipes) as never);\n}\n\n/** Creates a TView instance */\nexport function createTView(\n    defs: DirectiveDefListOrFactory | null, pipes: PipeDefListOrFactory | null): TView {\n  return {\n    data: [],\n    directives: null,\n    firstTemplatePass: true,\n    initHooks: null,\n    checkHooks: null,\n    contentHooks: null,\n    contentCheckHooks: null,\n    viewHooks: null,\n    viewCheckHooks: null,\n    destroyHooks: null,\n    pipeDestroyHooks: null,\n    hostBindings: null,\n    components: null,\n    directiveRegistry: typeof defs === 'function' ? defs() : defs,\n    pipeRegistry: typeof pipes === 'function' ? pipes() : pipes,\n    currentMatches: null\n  };\n}\n\nfunction setUpAttributes(native: RElement, attrs: string[]): void {\n  ngDevMode && assertEqual(attrs.length % 2, 0, 'each attribute should have a key and a value');\n\n  const isProc = isProceduralRenderer(renderer);\n  for (let i = 0; i < attrs.length; i += 2) {\n    const attrName = attrs[i];\n    if (attrName !== NG_PROJECT_AS_ATTR_NAME) {\n      const attrVal = attrs[i + 1];\n      isProc ? (renderer as ProceduralRenderer3).setAttribute(native, attrName, attrVal) :\n               native.setAttribute(attrName, attrVal);\n    }\n  }\n}\n\nexport function createError(text: string, token: any) {\n  return new Error(`Renderer: ${text} [${stringify(token)}]`);\n}\n\n\n/**\n * Locates the host native element, used for bootstrapping existing nodes into rendering pipeline.\n *\n * @param elementOrSelector Render element or CSS selector to locate the element.\n */\nexport function locateHostElement(\n    factory: RendererFactory3, elementOrSelector: RElement | string): RElement|null {\n  ngDevMode && assertDataInRange(-1);\n  rendererFactory = factory;\n  const defaultRenderer = factory.createRenderer(null, null);\n  const rNode = typeof elementOrSelector === 'string' ?\n      (isProceduralRenderer(defaultRenderer) ?\n           defaultRenderer.selectRootElement(elementOrSelector) :\n           defaultRenderer.querySelector(elementOrSelector)) :\n      elementOrSelector;\n  if (ngDevMode && !rNode) {\n    if (typeof elementOrSelector === 'string') {\n      throw createError('Host node with selector not found:', elementOrSelector);\n    } else {\n      throw createError('Host node is required:', elementOrSelector);\n    }\n  }\n  return rNode;\n}\n\n/**\n * Creates the host LNode.\n *\n * @param rNode Render host element.\n * @param def ComponentDef\n *\n * @returns LElementNode created\n */\nexport function hostElement(\n    tag: string, rNode: RElement | null, def: ComponentDef<any>): LElementNode {\n  resetApplicationState();\n  const node = createLNode(\n      0, LNodeType.Element, rNode,\n      createLView(\n          -1, renderer, getOrCreateTView(def.template, def.directiveDefs, def.pipeDefs), null, null,\n          def.onPush ? LViewFlags.Dirty : LViewFlags.CheckAlways));\n\n  if (firstTemplatePass) {\n    node.tNode = createTNode(tag as string, null, null);\n    node.tNode.flags = TNodeFlags.isComponent;\n    if (def.diPublic) def.diPublic(def);\n    currentView.tView.directives = [def];\n  }\n\n  return node;\n}\n\n\n/**\n * Adds an event listener to the current node.\n *\n * If an output exists on one of the node's directives, it also subscribes to the output\n * and saves the subscription for later cleanup.\n *\n * @param eventName Name of the event\n * @param listenerFn The function to be called when event emits\n * @param useCapture Whether or not to use capture in event listener.\n */\nexport function listener(\n    eventName: string, listenerFn: (e?: any) => any, useCapture = false): void {\n  ngDevMode && assertPreviousIsParent();\n  const node = previousOrParentNode;\n  const native = node.native as RElement;\n\n  // In order to match current behavior, native DOM event listeners must be added for all\n  // events (including outputs).\n  const cleanupFns = cleanup || (cleanup = currentView.cleanup = []);\n  if (isProceduralRenderer(renderer)) {\n    const wrappedListener = wrapListenerWithDirtyLogic(currentView, listenerFn);\n    const cleanupFn = renderer.listen(native, eventName, wrappedListener);\n    cleanupFns.push(cleanupFn, null);\n  } else {\n    const wrappedListener = wrapListenerWithDirtyAndDefault(currentView, listenerFn);\n    native.addEventListener(eventName, wrappedListener, useCapture);\n    cleanupFns.push(eventName, native, wrappedListener, useCapture);\n  }\n\n  let tNode: TNode|null = node.tNode !;\n  if (tNode.outputs === undefined) {\n    // if we create TNode here, inputs must be undefined so we know they still need to be\n    // checked\n    tNode.outputs = generatePropertyAliases(node.tNode !.flags, BindingDirection.Output);\n  }\n\n  const outputs = tNode.outputs;\n  let outputData: PropertyAliasValue|undefined;\n  if (outputs && (outputData = outputs[eventName])) {\n    createOutput(outputData, listenerFn);\n  }\n}\n\n/**\n * Iterates through the outputs associated with a particular event name and subscribes to\n * each output.\n */\nfunction createOutput(outputs: PropertyAliasValue, listener: Function): void {\n  for (let i = 0; i < outputs.length; i += 2) {\n    ngDevMode && assertDataInRange(outputs[i] as number, directives !);\n    const subscription = directives ![outputs[i] as number][outputs[i + 1]].subscribe(listener);\n    cleanup !.push(subscription.unsubscribe, subscription);\n  }\n}\n\n/** Mark the end of the element. */\nexport function elementEnd() {\n  if (isParent) {\n    isParent = false;\n  } else {\n    ngDevMode && assertHasParent();\n    previousOrParentNode = previousOrParentNode.parent !;\n  }\n  ngDevMode && assertNodeType(previousOrParentNode, LNodeType.Element);\n  const queries = previousOrParentNode.queries;\n  queries && queries.addNode(previousOrParentNode);\n  queueLifecycleHooks(previousOrParentNode.tNode !.flags, currentView);\n}\n\n/**\n * Updates the value of removes an attribute on an Element.\n *\n * @param number index The index of the element in the data array\n * @param name name The name of the attribute.\n * @param value value The attribute is removed when value is `null` or `undefined`.\n *                  Otherwise the attribute value is set to the stringified value.\n * @param sanitizer An optional function used to sanitize the value.\n */\nexport function elementAttribute(\n    index: number, name: string, value: any, sanitizer?: Sanitizer): void {\n  if (value !== NO_CHANGE) {\n    const element: LElementNode = data[index];\n    if (value == null) {\n      isProceduralRenderer(renderer) ? renderer.removeAttribute(element.native, name) :\n                                       element.native.removeAttribute(name);\n    } else {\n      const strValue = sanitizer == null ? stringify(value) : sanitizer(value);\n      isProceduralRenderer(renderer) ? renderer.setAttribute(element.native, name, strValue) :\n                                       element.native.setAttribute(name, strValue);\n    }\n  }\n}\n\n/**\n * Update a property on an Element.\n *\n * If the property name also exists as an input property on one of the element's directives,\n * the component property will be set instead of the element property. This check must\n * be conducted at runtime so child components that add new @Inputs don't have to be re-compiled.\n *\n * @param index The index of the element to update in the data array\n * @param propName Name of property. Because it is going to DOM, this is not subject to\n *        renaming as part of minification.\n * @param value New value to write.\n * @param sanitizer An optional function used to sanitize the value.\n */\n\nexport function elementProperty<T>(\n    index: number, propName: string, value: T | NO_CHANGE, sanitizer?: Sanitizer): void {\n  if (value === NO_CHANGE) return;\n  const node = data[index] as LElementNode;\n  const tNode = node.tNode !;\n  // if tNode.inputs is undefined, a listener has created outputs, but inputs haven't\n  // yet been checked\n  if (tNode && tNode.inputs === undefined) {\n    // mark inputs as checked\n    tNode.inputs = generatePropertyAliases(node.tNode !.flags, BindingDirection.Input);\n  }\n\n  const inputData = tNode && tNode.inputs;\n  let dataValue: PropertyAliasValue|undefined;\n  if (inputData && (dataValue = inputData[propName])) {\n    setInputsForProperty(dataValue, value);\n    markDirtyIfOnPush(node);\n  } else {\n    // It is assumed that the sanitizer is only added when the compiler determines that the property\n    // is risky, so sanitization can be done without further checks.\n    value = sanitizer != null ? (sanitizer(value) as any) : value;\n    const native = node.native;\n    isProceduralRenderer(renderer) ? renderer.setProperty(native, propName, value) :\n                                     (native.setProperty ? native.setProperty(propName, value) :\n                                                           (native as any)[propName] = value);\n  }\n}\n\n/**\n * Constructs a TNode object from the arguments.\n *\n * @param tagName\n * @param attrs\n * @param data\n * @param localNames A list of local names and their matching indices\n * @returns the TNode object\n */\nfunction createTNode(\n    tagName: string | null, attrs: string[] | null, data: TContainer | null): TNode {\n  return {\n    flags: 0,\n    tagName: tagName,\n    attrs: attrs,\n    localNames: null,\n    initialInputs: undefined,\n    inputs: undefined,\n    outputs: undefined,\n    data: data\n  };\n}\n\n/**\n * Given a list of directive indices and minified input names, sets the\n * input properties on the corresponding directives.\n */\nfunction setInputsForProperty(inputs: PropertyAliasValue, value: any): void {\n  for (let i = 0; i < inputs.length; i += 2) {\n    ngDevMode && assertDataInRange(inputs[i] as number, directives !);\n    directives ![inputs[i] as number][inputs[i + 1]] = value;\n  }\n}\n\n/**\n * Consolidates all inputs or outputs of all directives on this logical node.\n *\n * @param number lNodeFlags logical node flags\n * @param Direction direction whether to consider inputs or outputs\n * @returns PropertyAliases|null aggregate of all properties if any, `null` otherwise\n */\nfunction generatePropertyAliases(\n    tNodeFlags: TNodeFlags, direction: BindingDirection): PropertyAliases|null {\n  const count = tNodeFlags & TNodeFlags.DirectiveCountMask;\n  let propStore: PropertyAliases|null = null;\n\n  if (count > 0) {\n    const start = tNodeFlags >> TNodeFlags.DirectiveStartingIndexShift;\n    const end = start + count;\n    const isInput = direction === BindingDirection.Input;\n    const defs = currentView.tView.directives !;\n\n    for (let i = start; i < end; i++) {\n      const directiveDef = defs[i] as DirectiveDef<any>;\n      const propertyAliasMap: {[publicName: string]: string} =\n          isInput ? directiveDef.inputs : directiveDef.outputs;\n      for (let publicName in propertyAliasMap) {\n        if (propertyAliasMap.hasOwnProperty(publicName)) {\n          propStore = propStore || {};\n          const internalName = propertyAliasMap[publicName];\n          const hasProperty = propStore.hasOwnProperty(publicName);\n          hasProperty ? propStore[publicName].push(i, internalName) :\n                        (propStore[publicName] = [i, internalName]);\n        }\n      }\n    }\n  }\n  return propStore;\n}\n\n/**\n * Add or remove a class in a `classList` on a DOM element.\n *\n * This instruction is meant to handle the [class.foo]=\"exp\" case\n *\n * @param index The index of the element to update in the data array\n * @param className Name of class to toggle. Because it is going to DOM, this is not subject to\n *        renaming as part of minification.\n * @param value A value indicating if a given class should be added or removed.\n */\nexport function elementClassNamed<T>(index: number, className: string, value: T | NO_CHANGE): void {\n  if (value !== NO_CHANGE) {\n    const lElement = data[index] as LElementNode;\n    if (value) {\n      isProceduralRenderer(renderer) ? renderer.addClass(lElement.native, className) :\n                                       lElement.native.classList.add(className);\n\n    } else {\n      isProceduralRenderer(renderer) ? renderer.removeClass(lElement.native, className) :\n                                       lElement.native.classList.remove(className);\n    }\n  }\n}\n\n/**\n * Set the `className` property on a DOM element.\n *\n * This instruction is meant to handle the `[class]=\"exp\"` usage.\n *\n * `elementClass` instruction writes the value to the \"element's\" `className` property.\n *\n * @param index The index of the element to update in the data array\n * @param value A value indicating a set of classes which should be applied. The method overrides\n *   any existing classes. The value is stringified (`toString`) before it is applied to the\n *   element.\n */\nexport function elementClass<T>(index: number, value: T | NO_CHANGE): void {\n  if (value !== NO_CHANGE) {\n    // TODO: This is a naive implementation which simply writes value to the `className`. In the\n    // future\n    // we will add logic here which would work with the animation code.\n    const lElement: LElementNode = data[index];\n    isProceduralRenderer(renderer) ? renderer.setProperty(lElement.native, 'className', value) :\n                                     lElement.native['className'] = stringify(value);\n  }\n}\n\n/**\n * Update a given style on an Element.\n *\n * @param index Index of the element to change in the data array\n * @param styleName Name of property. Because it is going to DOM this is not subject to\n *        renaming as part of minification.\n * @param value New value to write (null to remove).\n * @param suffix Optional suffix. Used with scalar values to add unit such as `px`.\n * @param sanitizer An optional function used to transform the value typically used for\n *        sanitization.\n */\nexport function elementStyleNamed<T>(\n    index: number, styleName: string, value: T | NO_CHANGE, suffix?: string): void;\nexport function elementStyleNamed<T>(\n    index: number, styleName: string, value: T | NO_CHANGE, sanitizer?: Sanitizer): void;\nexport function elementStyleNamed<T>(\n    index: number, styleName: string, value: T | NO_CHANGE,\n    suffixOrSanitizer?: string | Sanitizer): void {\n  if (value !== NO_CHANGE) {\n    const lElement: LElementNode = data[index];\n    if (value == null) {\n      isProceduralRenderer(renderer) ?\n          renderer.removeStyle(lElement.native, styleName, RendererStyleFlags3.DashCase) :\n          lElement.native['style'].removeProperty(styleName);\n    } else {\n      let strValue =\n          typeof suffixOrSanitizer == 'function' ? suffixOrSanitizer(value) : stringify(value);\n      if (typeof suffixOrSanitizer == 'string') strValue = strValue + suffixOrSanitizer;\n      isProceduralRenderer(renderer) ?\n          renderer.setStyle(lElement.native, styleName, strValue, RendererStyleFlags3.DashCase) :\n          lElement.native['style'].setProperty(styleName, strValue);\n    }\n  }\n}\n\n/**\n * Set the `style` property on a DOM element.\n *\n * This instruction is meant to handle the `[style]=\"exp\"` usage.\n *\n *\n * @param index The index of the element to update in the data array\n * @param value A value indicating if a given style should be added or removed.\n *   The expected shape of `value` is an object where keys are style names and the values\n *   are their corresponding values to set. If value is falsy than the style is remove. An absence\n *   of style does not cause that style to be removed. `NO_CHANGE` implies that no update should be\n *   performed.\n */\nexport function elementStyle<T>(\n    index: number, value: {[styleName: string]: any} | NO_CHANGE): void {\n  if (value !== NO_CHANGE) {\n    // TODO: This is a naive implementation which simply writes value to the `style`. In the future\n    // we will add logic here which would work with the animation code.\n    const lElement = data[index] as LElementNode;\n    if (isProceduralRenderer(renderer)) {\n      renderer.setProperty(lElement.native, 'style', value);\n    } else {\n      const style = lElement.native['style'];\n      for (let i = 0, keys = Object.keys(value); i < keys.length; i++) {\n        const styleName: string = keys[i];\n        const styleValue: any = (value as any)[styleName];\n        styleValue == null ? style.removeProperty(styleName) :\n                             style.setProperty(styleName, styleValue);\n      }\n    }\n  }\n}\n\n\n\n//////////////////////////\n//// Text\n//////////////////////////\n\n/**\n * Create static text node\n *\n * @param index Index of the node in the data array.\n * @param value Value to write. This value will be stringified.\n */\nexport function text(index: number, value?: any): void {\n  ngDevMode &&\n      assertEqual(\n          currentView.bindingStartIndex, -1, 'text nodes should be created before bindings');\n  const textNode = createTextNode(value, renderer);\n  const node = createLNode(index, LNodeType.Element, textNode);\n  // Text nodes are self closing.\n  isParent = false;\n  appendChild(node.parent !, textNode, currentView);\n}\n\n/**\n * Create text node with binding\n * Bindings should be handled externally with the proper bind(1-8) method\n *\n * @param index Index of the node in the data array.\n * @param value Stringified value to write.\n */\nexport function textBinding<T>(index: number, value: T | NO_CHANGE): void {\n  ngDevMode && assertDataInRange(index);\n  let existingNode = data[index] as LTextNode;\n  ngDevMode && assertNotNull(existingNode, 'LNode should exist');\n  ngDevMode && assertNotNull(existingNode.native, 'native element should exist');\n  value !== NO_CHANGE &&\n      (isProceduralRenderer(renderer) ? renderer.setValue(existingNode.native, stringify(value)) :\n                                        existingNode.native.textContent = stringify(value));\n}\n\n//////////////////////////\n//// Directive\n//////////////////////////\n\n/**\n * Create a directive.\n *\n * NOTE: directives can be created in order other than the index order. They can also\n *       be retrieved before they are created in which case the value will be null.\n *\n * @param directive The directive instance.\n * @param directiveDef DirectiveDef object which contains information about the template.\n */\nexport function directiveCreate<T>(\n    index: number, directive: T, directiveDef: DirectiveDef<T>| ComponentDef<T>): T {\n  const instance = baseDirectiveCreate(index, directive, directiveDef);\n\n  ngDevMode && assertNotNull(previousOrParentNode.tNode, 'previousOrParentNode.tNode');\n  const tNode = previousOrParentNode.tNode;\n\n  const isComponent = (directiveDef as ComponentDef<T>).template;\n  if (isComponent) {\n    addComponentLogic(index, directive, directiveDef as ComponentDef<T>);\n  }\n\n  if (firstTemplatePass) {\n    // Init hooks are queued now so ngOnInit is called in host components before\n    // any projected components.\n    queueInitHooks(index, directiveDef.onInit, directiveDef.doCheck, currentView.tView);\n\n    if (directiveDef.hostBindings) queueHostBindingForCheck(index);\n  }\n\n  if (tNode && tNode.attrs) {\n    setInputsFromAttrs(index, instance, directiveDef.inputs, tNode);\n  }\n\n  return instance;\n}\n\nfunction addComponentLogic<T>(index: number, instance: T, def: ComponentDef<T>): void {\n  const tView = getOrCreateTView(def.template, def.directiveDefs, def.pipeDefs);\n\n  // Only component views should be added to the view tree directly. Embedded views are\n  // accessed through their containers because they may be removed / re-added later.\n  const hostView = addToViewTree(\n      currentView, createLView(\n                       -1, rendererFactory.createRenderer(\n                               previousOrParentNode.native as RElement, def.rendererType),\n                       tView, null, null, def.onPush ? LViewFlags.Dirty : LViewFlags.CheckAlways));\n\n  (previousOrParentNode.data as any) = hostView;\n  (hostView.node as any) = previousOrParentNode;\n\n  initChangeDetectorIfExisting(previousOrParentNode.nodeInjector, instance, hostView);\n\n  if (firstTemplatePass) queueComponentIndexForCheck(index);\n}\n\n/**\n * A lighter version of directiveCreate() that is used for the root component\n *\n * This version does not contain features that we don't already support at root in\n * current Angular. Example: local refs and inputs on root component.\n */\nexport function baseDirectiveCreate<T>(\n    index: number, directive: T, directiveDef: DirectiveDef<T>| ComponentDef<T>): T {\n  ngDevMode &&\n      assertEqual(\n          currentView.bindingStartIndex, -1, 'directives should be created before any bindings');\n  ngDevMode && assertPreviousIsParent();\n\n  Object.defineProperty(\n      directive, NG_HOST_SYMBOL, {enumerable: false, value: previousOrParentNode});\n\n  if (directives == null) currentView.directives = directives = [];\n\n  ngDevMode && assertDataNext(index, directives);\n  directives[index] = directive;\n\n  if (firstTemplatePass) {\n    const flags = previousOrParentNode.tNode !.flags;\n    if ((flags & TNodeFlags.DirectiveCountMask) === 0) {\n      // When the first directive is created:\n      // - save the index,\n      // - set the number of directives to 1\n      previousOrParentNode.tNode !.flags =\n          index << TNodeFlags.DirectiveStartingIndexShift | flags & TNodeFlags.isComponent | 1;\n    } else {\n      // Only need to bump the size when subsequent directives are created\n      ngDevMode && assertNotEqual(\n                       flags & TNodeFlags.DirectiveCountMask, TNodeFlags.DirectiveCountMask,\n                       'Reached the max number of directives');\n      previousOrParentNode.tNode !.flags++;\n    }\n  } else {\n    const diPublic = directiveDef !.diPublic;\n    if (diPublic) diPublic(directiveDef !);\n  }\n\n  if (directiveDef !.attributes != null && previousOrParentNode.type == LNodeType.Element) {\n    setUpAttributes(\n        (previousOrParentNode as LElementNode).native, directiveDef !.attributes as string[]);\n  }\n\n  return directive;\n}\n\n/**\n * Sets initial input properties on directive instances from attribute data\n *\n * @param directiveIndex Index of the directive in directives array\n * @param instance Instance of the directive on which to set the initial inputs\n * @param inputs The list of inputs from the directive def\n * @param tNode The static data for this node\n */\nfunction setInputsFromAttrs<T>(\n    directiveIndex: number, instance: T, inputs: {[key: string]: string}, tNode: TNode): void {\n  let initialInputData = tNode.initialInputs as InitialInputData | undefined;\n  if (initialInputData === undefined || directiveIndex >= initialInputData.length) {\n    initialInputData = generateInitialInputs(directiveIndex, inputs, tNode);\n  }\n\n  const initialInputs: InitialInputs|null = initialInputData[directiveIndex];\n  if (initialInputs) {\n    for (let i = 0; i < initialInputs.length; i += 2) {\n      (instance as any)[initialInputs[i]] = initialInputs[i + 1];\n    }\n  }\n}\n\n/**\n * Generates initialInputData for a node and stores it in the template's static storage\n * so subsequent template invocations don't have to recalculate it.\n *\n * initialInputData is an array containing values that need to be set as input properties\n * for directives on this node, but only once on creation. We need this array to support\n * the case where you set an @Input property of a directive using attribute-like syntax.\n * e.g. if you have a `name` @Input, you can set it once like this:\n *\n * <my-component name=\"Bess\"></my-component>\n *\n * @param directiveIndex Index to store the initial input data\n * @param inputs The list of inputs from the directive def\n * @param tNode The static data on this node\n */\nfunction generateInitialInputs(\n    directiveIndex: number, inputs: {[key: string]: string}, tNode: TNode): InitialInputData {\n  const initialInputData: InitialInputData = tNode.initialInputs || (tNode.initialInputs = []);\n  initialInputData[directiveIndex] = null;\n\n  const attrs = tNode.attrs !;\n  for (let i = 0; i < attrs.length; i += 2) {\n    const attrName = attrs[i];\n    const minifiedInputName = inputs[attrName];\n    if (minifiedInputName !== undefined) {\n      const inputsToStore: InitialInputs =\n          initialInputData[directiveIndex] || (initialInputData[directiveIndex] = []);\n      inputsToStore.push(minifiedInputName, attrs[i + 1]);\n    }\n  }\n  return initialInputData;\n}\n\n\n//////////////////////////\n//// ViewContainer & View\n//////////////////////////\n\n\nexport function createLContainer(\n    parentLNode: LNode, currentView: LView, template?: ComponentTemplate<any>): LContainer {\n  ngDevMode && assertNotNull(parentLNode, 'containers should have a parent');\n  return <LContainer>{\n    views: [],\n    nextIndex: 0,\n    // If the direct parent of the container is a view, its views will need to be added\n    // through insertView() when its parent view is being inserted:\n    renderParent: canInsertNativeNode(parentLNode, currentView) ? parentLNode : null,\n    template: template == null ? null : template,\n    next: null,\n    parent: currentView,\n    dynamicViewCount: 0,\n    queries: null\n  };\n}\n\n/**\n * Creates an LContainerNode.\n *\n * Only `LViewNodes` can go into `LContainerNodes`.\n *\n * @param index The index of the container in the data array\n * @param template Optional inline template\n * @param tagName The name of the container element, if applicable\n * @param attrs The attrs attached to the container, if applicable\n * @param localRefs A set of local reference bindings on the element.\n */\nexport function container(\n    index: number, template?: ComponentTemplate<any>, tagName?: string, attrs?: string[],\n    localRefs?: string[] | null): void {\n  ngDevMode && assertEqual(\n                   currentView.bindingStartIndex, -1,\n                   'container nodes should be created before any bindings');\n\n  const currentParent = isParent ? previousOrParentNode : previousOrParentNode.parent !;\n  const lContainer = createLContainer(currentParent, currentView, template);\n\n  const node = createLNode(index, LNodeType.Container, undefined, lContainer);\n\n  // Containers are added to the current view tree instead of their embedded views\n  // because views can be removed and re-inserted.\n  addToViewTree(currentView, node.data);\n  createDirectivesAndLocals(index, tagName || null, attrs, localRefs, []);\n\n  isParent = false;\n  ngDevMode && assertNodeType(previousOrParentNode, LNodeType.Container);\n  const queries = node.queries;\n  if (queries) {\n    // check if a given container node matches\n    queries.addNode(node);\n    // prepare place for matching nodes from views inserted into a given container\n    lContainer.queries = queries.container();\n  }\n}\n\n/**\n * Sets a container up to receive views.\n *\n * @param index The index of the container in the data array\n */\nexport function containerRefreshStart(index: number): void {\n  ngDevMode && assertDataInRange(index);\n  previousOrParentNode = data[index] as LNode;\n  ngDevMode && assertNodeType(previousOrParentNode, LNodeType.Container);\n  isParent = true;\n  (previousOrParentNode as LContainerNode).data.nextIndex = 0;\n  ngDevMode && assertSame(\n                   (previousOrParentNode as LContainerNode).native, undefined,\n                   `the container's native element should not have been set yet.`);\n\n  if (!checkNoChangesMode) {\n    // We need to execute init hooks here so ngOnInit hooks are called in top level views\n    // before they are called in embedded views (for backwards compatibility).\n    executeInitHooks(currentView, currentView.tView, creationMode);\n  }\n}\n\n/**\n * Marks the end of the LContainerNode.\n *\n * Marking the end of LContainerNode is the time when to child Views get inserted or removed.\n */\nexport function containerRefreshEnd(): void {\n  if (isParent) {\n    isParent = false;\n  } else {\n    ngDevMode && assertNodeType(previousOrParentNode, LNodeType.View);\n    ngDevMode && assertHasParent();\n    previousOrParentNode = previousOrParentNode.parent !;\n  }\n  ngDevMode && assertNodeType(previousOrParentNode, LNodeType.Container);\n  const container = previousOrParentNode as LContainerNode;\n  container.native = undefined;\n  ngDevMode && assertNodeType(container, LNodeType.Container);\n  const nextIndex = container.data.nextIndex;\n\n  // remove extra views at the end of the container\n  while (nextIndex < container.data.views.length) {\n    removeView(container, nextIndex);\n  }\n}\n\nfunction refreshDynamicChildren() {\n  for (let current = currentView.child; current !== null; current = current.next) {\n    if (current.dynamicViewCount !== 0 && (current as LContainer).views) {\n      const container = current as LContainer;\n      for (let i = 0; i < container.views.length; i++) {\n        const view = container.views[i];\n        // The directives and pipes are not needed here as an existing view is only being refreshed.\n        renderEmbeddedTemplate(view, view.data.template !, view.data.context !, renderer);\n      }\n    }\n  }\n}\n\n/**\n * Looks for a view with a given view block id inside a provided LContainer.\n * Removes views that need to be deleted in the process.\n *\n * @param containerNode where to search for views\n * @param startIdx starting index in the views array to search from\n * @param viewBlockId exact view block id to look for\n * @returns index of a found view or -1 if not found\n */\nfunction scanForView(\n    containerNode: LContainerNode, startIdx: number, viewBlockId: number): LViewNode|null {\n  const views = containerNode.data.views;\n  for (let i = startIdx; i < views.length; i++) {\n    const viewAtPositionId = views[i].data.id;\n    if (viewAtPositionId === viewBlockId) {\n      return views[i];\n    } else if (viewAtPositionId < viewBlockId) {\n      // found a view that should not be at this position - remove\n      removeView(containerNode, i);\n    } else {\n      // found a view with id grater than the one we are searching for\n      // which means that required view doesn't exist and can't be found at\n      // later positions in the views array - stop the search here\n      break;\n    }\n  }\n  return null;\n}\n\n/**\n * Marks the start of an embedded view.\n *\n * @param viewBlockId The ID of this view\n * @return boolean Whether or not this view is in creation mode\n */\nexport function embeddedViewStart(viewBlockId: number): RenderFlags {\n  const container =\n      (isParent ? previousOrParentNode : previousOrParentNode.parent !) as LContainerNode;\n  ngDevMode && assertNodeType(container, LNodeType.Container);\n  const lContainer = container.data;\n  let viewNode: LViewNode|null = scanForView(container, lContainer.nextIndex, viewBlockId);\n\n  if (viewNode) {\n    previousOrParentNode = viewNode;\n    ngDevMode && assertNodeType(previousOrParentNode, LNodeType.View);\n    isParent = true;\n    enterView(viewNode.data, viewNode);\n  } else {\n    // When we create a new LView, we always reset the state of the instructions.\n    const newView = createLView(\n        viewBlockId, renderer, getOrCreateEmbeddedTView(viewBlockId, container), null, null,\n        LViewFlags.CheckAlways);\n    if (lContainer.queries) {\n      newView.queries = lContainer.queries.enterView(lContainer.nextIndex);\n    }\n\n    enterView(newView, viewNode = createLNode(null, LNodeType.View, null, newView));\n  }\n  return getRenderFlags(viewNode.data);\n}\n\n/**\n * Initialize the TView (e.g. static data) for the active embedded view.\n *\n * Each embedded view needs to set the global tData variable to the static data for\n * that view. Otherwise, the view's static data for a particular node would overwrite\n * the static data for a node in the view above it with the same index (since it's in the\n * same template).\n *\n * @param viewIndex The index of the TView in TContainer\n * @param parent The parent container in which to look for the view's static data\n * @returns TView\n */\nfunction getOrCreateEmbeddedTView(viewIndex: number, parent: LContainerNode): TView {\n  ngDevMode && assertNodeType(parent, LNodeType.Container);\n  const tContainer = (parent !.tNode as TContainerNode).data;\n  if (viewIndex >= tContainer.length || tContainer[viewIndex] == null) {\n    const tView = currentView.tView;\n    tContainer[viewIndex] = createTView(tView.directiveRegistry, tView.pipeRegistry);\n  }\n  return tContainer[viewIndex];\n}\n\n/** Marks the end of an embedded view. */\nexport function embeddedViewEnd(): void {\n  refreshView();\n  isParent = false;\n  const viewNode = previousOrParentNode = currentView.node as LViewNode;\n  const containerNode = previousOrParentNode.parent as LContainerNode;\n  if (containerNode) {\n    ngDevMode && assertNodeType(viewNode, LNodeType.View);\n    ngDevMode && assertNodeType(containerNode, LNodeType.Container);\n    const lContainer = containerNode.data;\n\n    if (creationMode) {\n      // When projected nodes are going to be inserted, the renderParent of the dynamic container\n      // used by the ViewContainerRef must be set.\n      setRenderParentInProjectedNodes(lContainer.renderParent, viewNode);\n      // it is a new view, insert it into collection of views for a given container\n      insertView(containerNode, viewNode, lContainer.nextIndex);\n    }\n\n    lContainer.nextIndex++;\n  }\n  leaveView(currentView !.parent !);\n  ngDevMode && assertEqual(isParent, false, 'isParent');\n  ngDevMode && assertNodeType(previousOrParentNode, LNodeType.View);\n}\n\n/**\n * For nodes which are projected inside an embedded view, this function sets the renderParent\n * of their dynamic LContainerNode.\n * @param renderParent the renderParent of the LContainer which contains the embedded view.\n * @param viewNode the embedded view.\n */\nfunction setRenderParentInProjectedNodes(\n    renderParent: LElementNode | null, viewNode: LViewNode): void {\n  if (renderParent != null) {\n    let node = viewNode.child;\n    while (node) {\n      if (node.type === LNodeType.Projection) {\n        let nodeToProject: LNode|null = (node as LProjectionNode).data.head;\n        const lastNodeToProject = (node as LProjectionNode).data.tail;\n        while (nodeToProject) {\n          if (nodeToProject.dynamicLContainerNode) {\n            nodeToProject.dynamicLContainerNode.data.renderParent = renderParent;\n          }\n          nodeToProject = nodeToProject === lastNodeToProject ? null : nodeToProject.pNextOrParent;\n        }\n      }\n      node = node.next;\n    }\n  }\n}\n\n/////////////\n\n/**\n * Refreshes components by entering the component view and processing its bindings, queries, etc.\n *\n * @param directiveIndex\n * @param elementIndex\n */\nexport function componentRefresh<T>(directiveIndex: number, elementIndex: number): void {\n  ngDevMode && assertDataInRange(elementIndex);\n  const element = data ![elementIndex] as LElementNode;\n  ngDevMode && assertNodeType(element, LNodeType.Element);\n  ngDevMode && assertNotNull(element.data, `Component's host node should have an LView attached.`);\n  const hostView = element.data !;\n\n  // Only attached CheckAlways components or attached, dirty OnPush components should be checked\n  if (viewAttached(hostView) && hostView.flags & (LViewFlags.CheckAlways | LViewFlags.Dirty)) {\n    ngDevMode && assertDataInRange(directiveIndex, directives !);\n    const def = currentView.tView.directives ![directiveIndex] as ComponentDef<T>;\n\n    detectChangesInternal(\n        hostView, element, def, getDirectiveInstance(directives ![directiveIndex]));\n  }\n}\n\n/** Returns a boolean for whether the view is attached */\nfunction viewAttached(view: LView): boolean {\n  return (view.flags & LViewFlags.Attached) === LViewFlags.Attached;\n}\n\n/**\n * Instruction to distribute projectable nodes among <ng-content> occurrences in a given template.\n * It takes all the selectors from the entire component's template and decides where\n * each projected node belongs (it re-distributes nodes among \"buckets\" where each \"bucket\" is\n * backed by a selector).\n *\n * This function requires CSS selectors to be provided in 2 forms: parsed (by a compiler) and text,\n * un-parsed form.\n *\n * The parsed form is needed for efficient matching of a node against a given CSS selector.\n * The un-parsed, textual form is needed for support of the ngProjectAs attribute.\n *\n * Having a CSS selector in 2 different formats is not ideal, but alternatives have even more\n * drawbacks:\n * - having only a textual form would require runtime parsing of CSS selectors;\n * - we can't have only a parsed as we can't re-construct textual form from it (as entered by a\n * template author).\n *\n * @param selectors A collection of parsed CSS selectors\n * @param rawSelectors A collection of CSS selectors in the raw, un-parsed form\n */\nexport function projectionDef(\n    index: number, selectors?: CssSelectorList[], textSelectors?: string[]): void {\n  const noOfNodeBuckets = selectors ? selectors.length + 1 : 1;\n  const distributedNodes = new Array<LNode[]>(noOfNodeBuckets);\n  for (let i = 0; i < noOfNodeBuckets; i++) {\n    distributedNodes[i] = [];\n  }\n\n  const componentNode = findComponentHost(currentView);\n  let componentChild = componentNode.child;\n\n  while (componentChild !== null) {\n    // execute selector matching logic if and only if:\n    // - there are selectors defined\n    // - a node has a tag name / attributes that can be matched\n    if (selectors && componentChild.tNode) {\n      const matchedIdx = matchingSelectorIndex(componentChild.tNode, selectors, textSelectors !);\n      distributedNodes[matchedIdx].push(componentChild);\n    } else {\n      distributedNodes[0].push(componentChild);\n    }\n\n    componentChild = componentChild.next;\n  }\n\n  ngDevMode && assertDataNext(index);\n  data[index] = distributedNodes;\n}\n\n/**\n * Updates the linked list of a projection node, by appending another linked list.\n *\n * @param projectionNode Projection node whose projected nodes linked list has to be updated\n * @param appendedFirst First node of the linked list to append.\n * @param appendedLast Last node of the linked list to append.\n */\nfunction appendToProjectionNode(\n    projectionNode: LProjectionNode,\n    appendedFirst: LElementNode | LTextNode | LContainerNode | null,\n    appendedLast: LElementNode | LTextNode | LContainerNode | null) {\n  ngDevMode && assertEqual(\n                   !!appendedFirst, !!appendedLast,\n                   'appendedFirst can be null if and only if appendedLast is also null');\n  if (!appendedLast) {\n    // nothing to append\n    return;\n  }\n  const projectionNodeData = projectionNode.data;\n  if (projectionNodeData.tail) {\n    projectionNodeData.tail.pNextOrParent = appendedFirst;\n  } else {\n    projectionNodeData.head = appendedFirst;\n  }\n  projectionNodeData.tail = appendedLast;\n  appendedLast.pNextOrParent = projectionNode;\n}\n\n/**\n * Inserts previously re-distributed projected nodes. This instruction must be preceded by a call\n * to the projectionDef instruction.\n *\n * @param nodeIndex\n * @param localIndex - index under which distribution of projected nodes was memorized\n * @param selectorIndex:\n *        - 0 when the selector is `*` (or unspecified as this is the default value),\n *        - 1 based index of the selector from the {@link projectionDef}\n */\nexport function projection(\n    nodeIndex: number, localIndex: number, selectorIndex: number = 0, attrs?: string[]): void {\n  const node = createLNode(nodeIndex, LNodeType.Projection, null, {head: null, tail: null});\n\n  if (node.tNode == null) {\n    node.tNode = createTNode(null, attrs || null, null);\n  }\n\n  // `<ng-content>` has no content\n  isParent = false;\n  const currentParent = node.parent;\n\n  // re-distribution of projectable nodes is memorized on a component's view level\n  const componentNode = findComponentHost(currentView);\n  const componentLView = componentNode.data !;\n  const nodesForSelector = componentLView.data ![localIndex][selectorIndex];\n\n  // build the linked list of projected nodes:\n  for (let i = 0; i < nodesForSelector.length; i++) {\n    const nodeToProject = nodesForSelector[i];\n    if (nodeToProject.type === LNodeType.Projection) {\n      // Reprojecting a projection -> append the list of previously projected nodes\n      const previouslyProjected = (nodeToProject as LProjectionNode).data;\n      appendToProjectionNode(node, previouslyProjected.head, previouslyProjected.tail);\n    } else {\n      // Projecting a single node\n      appendToProjectionNode(\n          node, nodeToProject as LTextNode | LElementNode | LContainerNode,\n          nodeToProject as LTextNode | LElementNode | LContainerNode);\n    }\n  }\n\n  if (canInsertNativeNode(currentParent, currentView)) {\n    ngDevMode && assertNodeType(currentParent, LNodeType.Element);\n    // process each node in the list of projected nodes:\n    let nodeToProject: LNode|null = node.data.head;\n    const lastNodeToProject = node.data.tail;\n    while (nodeToProject) {\n      appendProjectedNode(\n          nodeToProject as LTextNode | LElementNode | LContainerNode, currentParent as LElementNode,\n          currentView);\n      nodeToProject = nodeToProject === lastNodeToProject ? null : nodeToProject.pNextOrParent;\n    }\n  }\n}\n\n/**\n * Given a current view, finds the nearest component's host (LElement).\n *\n * @param lView LView for which we want a host element node\n * @returns The host node\n */\nfunction findComponentHost(lView: LView): LElementNode {\n  let viewRootLNode = lView.node;\n  while (viewRootLNode.type === LNodeType.View) {\n    ngDevMode && assertNotNull(lView.parent, 'lView.parent');\n    lView = lView.parent !;\n    viewRootLNode = lView.node;\n  }\n\n  ngDevMode && assertNodeType(viewRootLNode, LNodeType.Element);\n  ngDevMode && assertNotNull(viewRootLNode.data, 'node.data');\n\n  return viewRootLNode as LElementNode;\n}\n\n/**\n * Adds a LView or a LContainer to the end of the current view tree.\n *\n * This structure will be used to traverse through nested views to remove listeners\n * and call onDestroy callbacks.\n *\n * @param currentView The view where LView or LContainer should be added\n * @param state The LView or LContainer to add to the view tree\n * @returns The state passed in\n */\nexport function addToViewTree<T extends LView|LContainer>(currentView: LView, state: T): T {\n  currentView.tail ? (currentView.tail.next = state) : (currentView.child = state);\n  currentView.tail = state;\n  return state;\n}\n\n///////////////////////////////\n//// Change detection\n///////////////////////////////\n\n/** If node is an OnPush component, marks its LView dirty. */\nexport function markDirtyIfOnPush(node: LElementNode): void {\n  // Because data flows down the component tree, ancestors do not need to be marked dirty\n  if (node.data && !(node.data.flags & LViewFlags.CheckAlways)) {\n    node.data.flags |= LViewFlags.Dirty;\n  }\n}\n\n/**\n * Wraps an event listener so its host view and its ancestor views will be marked dirty\n * whenever the event fires. Necessary to support OnPush components.\n */\nexport function wrapListenerWithDirtyLogic(view: LView, listenerFn: (e?: any) => any): (e: Event) =>\n    any {\n  return function(e: any) {\n    markViewDirty(view);\n    return listenerFn(e);\n  };\n}\n\n/**\n * Wraps an event listener so its host view and its ancestor views will be marked dirty\n * whenever the event fires. Also wraps with preventDefault behavior.\n */\nexport function wrapListenerWithDirtyAndDefault(\n    view: LView, listenerFn: (e?: any) => any): EventListener {\n  return function wrapListenerIn_markViewDirty(e: Event) {\n    markViewDirty(view);\n    if (listenerFn(e) === false) {\n      e.preventDefault();\n      // Necessary for legacy browsers that don't support preventDefault (e.g. IE)\n      e.returnValue = false;\n    }\n  };\n}\n\n/** Marks current view and all ancestors dirty */\nexport function markViewDirty(view: LView): void {\n  let currentView: LView|null = view;\n\n  while (currentView.parent != null) {\n    currentView.flags |= LViewFlags.Dirty;\n    currentView = currentView.parent;\n  }\n  currentView.flags |= LViewFlags.Dirty;\n\n  ngDevMode && assertNotNull(currentView !.context, 'rootContext');\n  scheduleTick(currentView !.context as RootContext);\n}\n\n\n/**\n * Used to schedule change detection on the whole application.\n *\n * Unlike `tick`, `scheduleTick` coalesces multiple calls into one change detection run.\n * It is usually called indirectly by calling `markDirty` when the view needs to be\n * re-rendered.\n *\n * Typically `scheduleTick` uses `requestAnimationFrame` to coalesce multiple\n * `scheduleTick` requests. The scheduling function can be overridden in\n * `renderComponent`'s `scheduler` option.\n */\nexport function scheduleTick<T>(rootContext: RootContext) {\n  if (rootContext.clean == _CLEAN_PROMISE) {\n    let res: null|((val: null) => void);\n    rootContext.clean = new Promise<null>((r) => res = r);\n    rootContext.scheduler(() => {\n      tick(rootContext.component);\n      res !(null);\n      rootContext.clean = _CLEAN_PROMISE;\n    });\n  }\n}\n\n/**\n * Used to perform change detection on the whole application.\n *\n * This is equivalent to `detectChanges`, but invoked on root component. Additionally, `tick`\n * executes lifecycle hooks and conditionally checks components based on their\n * `ChangeDetectionStrategy` and dirtiness.\n *\n * The preferred way to trigger change detection is to call `markDirty`. `markDirty` internally\n * schedules `tick` using a scheduler in order to coalesce multiple `markDirty` calls into a\n * single change detection run. By default, the scheduler is `requestAnimationFrame`, but can\n * be changed when calling `renderComponent` and providing the `scheduler` option.\n */\nexport function tick<T>(component: T): void {\n  const rootView = getRootView(component);\n  const rootComponent = (rootView.context as RootContext).component;\n  const hostNode = _getComponentHostLElementNode(rootComponent);\n\n  ngDevMode && assertNotNull(hostNode.data, 'Component host node should be attached to an LView');\n  renderComponentOrTemplate(hostNode, rootView, rootComponent);\n}\n\n/**\n * Retrieve the root view from any component by walking the parent `LView` until\n * reaching the root `LView`.\n *\n * @param component any component\n */\n\nexport function getRootView(component: any): LView {\n  ngDevMode && assertNotNull(component, 'component');\n  const lElementNode = _getComponentHostLElementNode(component);\n  let lView = lElementNode.view;\n  while (lView.parent) {\n    lView = lView.parent;\n  }\n  return lView;\n}\n\n/**\n * Synchronously perform change detection on a component (and possibly its sub-components).\n *\n * This function triggers change detection in a synchronous way on a component. There should\n * be very little reason to call this function directly since a preferred way to do change\n * detection is to {@link markDirty} the component and wait for the scheduler to call this method\n * at some future point in time. This is because a single user action often results in many\n * components being invalidated and calling change detection on each component synchronously\n * would be inefficient. It is better to wait until all components are marked as dirty and\n * then perform single change detection across all of the components\n *\n * @param component The component which the change detection should be performed on.\n */\nexport function detectChanges<T>(component: T): void {\n  const hostNode = _getComponentHostLElementNode(component);\n  ngDevMode && assertNotNull(hostNode.data, 'Component host node should be attached to an LView');\n  const componentIndex = hostNode.tNode !.flags >> TNodeFlags.DirectiveStartingIndexShift;\n  const def = hostNode.view.tView.directives ![componentIndex] as ComponentDef<T>;\n  detectChangesInternal(hostNode.data as LView, hostNode, def, component);\n}\n\n\n/**\n * Checks the change detector and its children, and throws if any changes are detected.\n *\n * This is used in development mode to verify that running change detection doesn't\n * introduce other changes.\n */\nexport function checkNoChanges<T>(component: T): void {\n  checkNoChangesMode = true;\n  try {\n    detectChanges(component);\n  } finally {\n    checkNoChangesMode = false;\n  }\n}\n\n/** Checks the view of the component provided. Does not gate on dirty checks or execute doCheck. */\nexport function detectChangesInternal<T>(\n    hostView: LView, hostNode: LElementNode, def: ComponentDef<T>, component: T) {\n  const oldView = enterView(hostView, hostNode);\n  const template = def.template;\n\n  try {\n    template(getRenderFlags(hostView), component);\n    refreshView();\n  } finally {\n    leaveView(oldView);\n  }\n}\n\n\n/**\n * Mark the component as dirty (needing change detection).\n *\n * Marking a component dirty will schedule a change detection on this\n * component at some point in the future. Marking an already dirty\n * component as dirty is a noop. Only one outstanding change detection\n * can be scheduled per component tree. (Two components bootstrapped with\n * separate `renderComponent` will have separate schedulers)\n *\n * When the root component is bootstrapped with `renderComponent`, a scheduler\n * can be provided.\n *\n * @param component Component to mark as dirty.\n */\nexport function markDirty<T>(component: T) {\n  ngDevMode && assertNotNull(component, 'component');\n  const lElementNode = _getComponentHostLElementNode(component);\n  markViewDirty(lElementNode.view);\n}\n\n///////////////////////////////\n//// Bindings & interpolations\n///////////////////////////////\n\nexport interface NO_CHANGE {\n  // This is a brand that ensures that this type can never match anything else\n  brand: 'NO_CHANGE';\n}\n\n/** A special value which designates that a value has not changed. */\nexport const NO_CHANGE = {} as NO_CHANGE;\n\n/**\n *  Initializes the binding start index. Will get inlined.\n *\n *  This function must be called before any binding related function is called\n *  (ie `bind()`, `interpolationX()`, `pureFunctionX()`)\n */\nfunction initBindings() {\n  ngDevMode && assertEqual(\n                   currentView.bindingStartIndex, -1,\n                   'Binding start index should only be set once, when null');\n  ngDevMode && assertEqual(\n                   currentView.bindingIndex, -1,\n                   'Binding index should not yet be set ' + currentView.bindingIndex);\n  currentView.bindingIndex = currentView.bindingStartIndex = data.length;\n}\n\n/**\n * Creates a single value binding.\n *\n * @param value Value to diff\n */\nexport function bind<T>(value: T | NO_CHANGE): T|NO_CHANGE {\n  if (currentView.bindingStartIndex < 0) {\n    initBindings();\n    return data[currentView.bindingIndex++] = value;\n  }\n\n  const changed: boolean =\n      value !== NO_CHANGE && isDifferent(data[currentView.bindingIndex], value);\n  if (changed) {\n    throwErrorIfNoChangesMode(\n        creationMode, checkNoChangesMode, data[currentView.bindingIndex], value);\n    data[currentView.bindingIndex] = value;\n  }\n  currentView.bindingIndex++;\n  return changed ? value : NO_CHANGE;\n}\n\n/**\n * Create interpolation bindings with a variable number of expressions.\n *\n * If there are 1 to 8 expressions `interpolation1()` to `interpolation8()` should be used instead.\n * Those are faster because there is no need to create an array of expressions and iterate over it.\n *\n * `values`:\n * - has static text at even indexes,\n * - has evaluated expressions at odd indexes.\n *\n * Returns the concatenated string when any of the arguments changes, `NO_CHANGE` otherwise.\n */\nexport function interpolationV(values: any[]): string|NO_CHANGE {\n  ngDevMode && assertLessThan(2, values.length, 'should have at least 3 values');\n  ngDevMode && assertEqual(values.length % 2, 1, 'should have an odd number of values');\n\n  let different = false;\n\n  for (let i = 1; i < values.length; i += 2) {\n    // Check if bindings (odd indexes) have changed\n    bindingUpdated(values[i]) && (different = true);\n  }\n\n  if (!different) {\n    return NO_CHANGE;\n  }\n\n  // Build the updated content\n  let content = values[0];\n  for (let i = 1; i < values.length; i += 2) {\n    content += stringify(values[i]) + values[i + 1];\n  }\n\n  return content;\n}\n\n/**\n * Creates an interpolation binding with 1 expression.\n *\n * @param prefix static value used for concatenation only.\n * @param v0 value checked for change.\n * @param suffix static value used for concatenation only.\n */\nexport function interpolation1(prefix: string, v0: any, suffix: string): string|NO_CHANGE {\n  const different = bindingUpdated(v0);\n\n  return different ? prefix + stringify(v0) + suffix : NO_CHANGE;\n}\n\n/** Creates an interpolation binding with 2 expressions. */\nexport function interpolation2(\n    prefix: string, v0: any, i0: string, v1: any, suffix: string): string|NO_CHANGE {\n  const different = bindingUpdated2(v0, v1);\n\n  return different ? prefix + stringify(v0) + i0 + stringify(v1) + suffix : NO_CHANGE;\n}\n\n/** Creates an interpolation bindings with 3 expressions. */\nexport function interpolation3(\n    prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any, suffix: string): string|\n    NO_CHANGE {\n  let different = bindingUpdated2(v0, v1);\n  different = bindingUpdated(v2) || different;\n\n  return different ? prefix + stringify(v0) + i0 + stringify(v1) + i1 + stringify(v2) + suffix :\n                     NO_CHANGE;\n}\n\n/** Create an interpolation binding with 4 expressions. */\nexport function interpolation4(\n    prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any, i2: string, v3: any,\n    suffix: string): string|NO_CHANGE {\n  const different = bindingUpdated4(v0, v1, v2, v3);\n\n  return different ?\n      prefix + stringify(v0) + i0 + stringify(v1) + i1 + stringify(v2) + i2 + stringify(v3) +\n          suffix :\n      NO_CHANGE;\n}\n\n/** Creates an interpolation binding with 5 expressions. */\nexport function interpolation5(\n    prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any, i2: string, v3: any,\n    i3: string, v4: any, suffix: string): string|NO_CHANGE {\n  let different = bindingUpdated4(v0, v1, v2, v3);\n  different = bindingUpdated(v4) || different;\n\n  return different ?\n      prefix + stringify(v0) + i0 + stringify(v1) + i1 + stringify(v2) + i2 + stringify(v3) + i3 +\n          stringify(v4) + suffix :\n      NO_CHANGE;\n}\n\n/** Creates an interpolation binding with 6 expressions. */\nexport function interpolation6(\n    prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any, i2: string, v3: any,\n    i3: string, v4: any, i4: string, v5: any, suffix: string): string|NO_CHANGE {\n  let different = bindingUpdated4(v0, v1, v2, v3);\n  different = bindingUpdated2(v4, v5) || different;\n\n  return different ?\n      prefix + stringify(v0) + i0 + stringify(v1) + i1 + stringify(v2) + i2 + stringify(v3) + i3 +\n          stringify(v4) + i4 + stringify(v5) + suffix :\n      NO_CHANGE;\n}\n\n/** Creates an interpolation binding with 7 expressions. */\nexport function interpolation7(\n    prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any, i2: string, v3: any,\n    i3: string, v4: any, i4: string, v5: any, i5: string, v6: any, suffix: string): string|\n    NO_CHANGE {\n  let different = bindingUpdated4(v0, v1, v2, v3);\n  different = bindingUpdated2(v4, v5) || different;\n  different = bindingUpdated(v6) || different;\n\n  return different ?\n      prefix + stringify(v0) + i0 + stringify(v1) + i1 + stringify(v2) + i2 + stringify(v3) + i3 +\n          stringify(v4) + i4 + stringify(v5) + i5 + stringify(v6) + suffix :\n      NO_CHANGE;\n}\n\n/** Creates an interpolation binding with 8 expressions. */\nexport function interpolation8(\n    prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any, i2: string, v3: any,\n    i3: string, v4: any, i4: string, v5: any, i5: string, v6: any, i6: string, v7: any,\n    suffix: string): string|NO_CHANGE {\n  let different = bindingUpdated4(v0, v1, v2, v3);\n  different = bindingUpdated4(v4, v5, v6, v7) || different;\n\n  return different ?\n      prefix + stringify(v0) + i0 + stringify(v1) + i1 + stringify(v2) + i2 + stringify(v3) + i3 +\n          stringify(v4) + i4 + stringify(v5) + i5 + stringify(v6) + i6 + stringify(v7) + suffix :\n      NO_CHANGE;\n}\n\n/** Store a value in the `data` at a given `index`. */\nexport function store<T>(index: number, value: T): void {\n  // We don't store any static data for local variables, so the first time\n  // we see the template, we should store as null to avoid a sparse array\n  if (index >= tData.length) {\n    tData[index] = null;\n  }\n  data[index] = value;\n}\n\n/** Retrieves a value from the `data`. */\nexport function load<T>(index: number): T {\n  ngDevMode && assertDataInRange(index);\n  return data[index];\n}\n\n/** Retrieves a value from the `directives` array. */\nexport function loadDirective<T>(index: number): T {\n  ngDevMode && assertNotNull(directives, 'Directives array should be defined if reading a dir.');\n  ngDevMode && assertDataInRange(index, directives !);\n  return directives ![index];\n}\n\n/** Gets the current binding value and increments the binding index. */\nexport function consumeBinding(): any {\n  ngDevMode && assertDataInRange(currentView.bindingIndex);\n  ngDevMode &&\n      assertNotEqual(\n          data[currentView.bindingIndex], NO_CHANGE, 'Stored value should never be NO_CHANGE.');\n  return data[currentView.bindingIndex++];\n}\n\n/** Updates binding if changed, then returns whether it was updated. */\nexport function bindingUpdated(value: any): boolean {\n  ngDevMode && assertNotEqual(value, NO_CHANGE, 'Incoming value should never be NO_CHANGE.');\n\n  if (currentView.bindingStartIndex < 0) {\n    initBindings();\n  } else if (isDifferent(data[currentView.bindingIndex], value)) {\n    throwErrorIfNoChangesMode(\n        creationMode, checkNoChangesMode, data[currentView.bindingIndex], value);\n  } else {\n    currentView.bindingIndex++;\n    return false;\n  }\n\n  data[currentView.bindingIndex++] = value;\n  return true;\n}\n\n/** Updates binding if changed, then returns the latest value. */\nexport function checkAndUpdateBinding(value: any): any {\n  bindingUpdated(value);\n  return value;\n}\n\n/** Updates 2 bindings if changed, then returns whether either was updated. */\nexport function bindingUpdated2(exp1: any, exp2: any): boolean {\n  const different = bindingUpdated(exp1);\n  return bindingUpdated(exp2) || different;\n}\n\n/** Updates 4 bindings if changed, then returns whether any was updated. */\nexport function bindingUpdated4(exp1: any, exp2: any, exp3: any, exp4: any): boolean {\n  const different = bindingUpdated2(exp1, exp2);\n  return bindingUpdated2(exp3, exp4) || different;\n}\n\nexport function getTView(): TView {\n  return currentView.tView;\n}\n\nexport function getDirectiveInstance<T>(instanceOrArray: T | [T]): T {\n  // Directives with content queries store an array in directives[directiveIndex]\n  // with the instance as the first index\n  return Array.isArray(instanceOrArray) ? instanceOrArray[0] : instanceOrArray;\n}\n\nexport function assertPreviousIsParent() {\n  assertEqual(isParent, true, 'previousOrParentNode should be a parent');\n}\n\nfunction assertHasParent() {\n  assertNotNull(previousOrParentNode.parent, 'previousOrParentNode should have a parent');\n}\n\nfunction assertDataInRange(index: number, arr?: any[]) {\n  if (arr == null) arr = data;\n  assertLessThan(index, arr ? arr.length : 0, 'index expected to be a valid data index');\n}\n\nfunction assertDataNext(index: number, arr?: any[]) {\n  if (arr == null) arr = data;\n  assertEqual(\n      arr.length, index, `index ${index} expected to be at the end of arr (length ${arr.length})`);\n}\n\nexport function _getComponentHostLElementNode<T>(component: T): LElementNode {\n  ngDevMode && assertNotNull(component, 'expecting component got null');\n  const lElementNode = (component as any)[NG_HOST_SYMBOL] as LElementNode;\n  ngDevMode && assertNotNull(component, 'object is not a component');\n  return lElementNode;\n}\n\nexport const CLEAN_PROMISE = _CLEAN_PROMISE;\nexport const ROOT_DIRECTIVE_INDICES = _ROOT_DIRECTIVE_INDICES;\n"]}