{"version":3,"file":"definition.js","sourceRoot":"","sources":["../../../../../../../packages/core/src/render3/interfaces/definition.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAoQA,MAAM,CAAC,qBAAM,6BAA6B,GAAG,CAAC,CAAC","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Provider} from '../../core';\nimport {RendererType2} from '../../render/api';\nimport {Type} from '../../type';\nimport {CssSelectorList} from './projection';\n\n/**\n * Definition of what a template rendering function should look like.\n */\nexport type ComponentTemplate<T> = {\n  (rf: RenderFlags, ctx: T): void; ngPrivateData?: never;\n};\n\n/**\n * Flags passed into template functions to determine which blocks (i.e. creation, update)\n * should be executed.\n *\n * Typically, a template runs both the creation block and the update block on initialization and\n * subsequent runs only execute the update block. However, dynamically created views require that\n * the creation block be executed separately from the update block (for backwards compat).\n */\nexport const enum RenderFlags {\n  /* Whether to run the creation block (e.g. create elements and directives) */\n  Create = 0b01,\n\n  /* Whether to run the update block (e.g. refresh bindings) */\n  Update = 0b10\n}\n\n/**\n * A subclass of `Type` which has a static `ngComponentDef`:`ComponentDef` field making it\n * consumable for rendering.\n */\nexport interface ComponentType<T> extends Type<T> { ngComponentDef: never; }\n\n/**\n * A subclass of `Type` which has a static `ngDirectiveDef`:`DirectiveDef` field making it\n * consumable for rendering.\n */\nexport interface DirectiveType<T> extends Type<T> { ngDirectiveDef: never; }\n\nexport const enum DirectiveDefFlags {ContentQuery = 0b10}\n\n/**\n * A subclass of `Type` which has a static `ngPipeDef`:`PipeDef` field making it\n * consumable for rendering.\n */\nexport interface PipeType<T> extends Type<T> { ngPipeDef: never; }\n\n/**\n * Runtime link information for Directives.\n *\n * This is internal data structure used by the render to link\n * directives into templates.\n *\n * NOTE: Always use `defineDirective` function to create this object,\n * never create the object directly since the shape of this object\n * can change between versions.\n *\n * See: {@link defineDirective}\n */\nexport interface DirectiveDef<T> {\n  /** Token representing the directive. Used by DI. */\n  type: Type<T>;\n\n  /** Function that makes a directive public to the DI system. */\n  diPublic: ((def: DirectiveDef<any>) => void)|null;\n\n  /** The selectors that will be used to match nodes to this directive. */\n  selectors: CssSelectorList;\n\n  /**\n   * A dictionary mapping the inputs' minified property names to their public API names, which\n   * are their aliases if any, or their original unminified property names\n   * (as in `@Input('alias') propertyName: any;`).\n   */\n  readonly inputs: {[P in keyof T]: P};\n\n  /**\n   * A dictionary mapping the outputs' minified property names to their public API names, which\n   * are their aliases if any, or their original unminified property names\n   * (as in `@Output('alias') propertyName: any;`).\n   */\n  readonly outputs: {[P in keyof T]: P};\n\n  /**\n   * Name under which the directive is exported (for use with local references in template)\n   */\n  readonly exportAs: string|null;\n\n  /**\n   * Factory function used to create a new directive instance.\n   *\n   * Usually returns the directive instance, but if the directive has a content query,\n   * it instead returns an array that contains the instance as well as content query data.\n   */\n  factory(): T|[T];\n\n  /** Refreshes host bindings on the associated directive. */\n  hostBindings: ((directiveIndex: number, elementIndex: number) => void)|null;\n\n  /**\n   * Static attributes to set on host element.\n   *\n   * Even indices: attribute name\n   * Odd indices: attribute value\n   */\n  attributes: string[]|null;\n\n  /* The following are lifecycle hooks for this component */\n  onInit: (() => void)|null;\n  doCheck: (() => void)|null;\n  afterContentInit: (() => void)|null;\n  afterContentChecked: (() => void)|null;\n  afterViewInit: (() => void)|null;\n  afterViewChecked: (() => void)|null;\n  onDestroy: (() => void)|null;\n}\n\n/**\n * Runtime link information for Components.\n *\n * This is internal data structure used by the render to link\n * components into templates.\n *\n * NOTE: Always use `defineComponent` function to create this object,\n * never create the object directly since the shape of this object\n * can change between versions.\n *\n * See: {@link defineComponent}\n */\nexport interface ComponentDef<T> extends DirectiveDef<T> {\n  /**\n   * The View template of the component.\n   *\n   * NOTE: only used with component directives.\n   */\n  readonly template: ComponentTemplate<T>;\n\n  /**\n   * Renderer type data of the component.\n   *\n   * NOTE: only used with component directives.\n   */\n  readonly rendererType: RendererType2|null;\n\n  /** Whether or not this component's ChangeDetectionStrategy is OnPush */\n  readonly onPush: boolean;\n\n  /**\n   * Defines the set of injectable providers that are visible to a Directive and its content DOM\n   * children.\n   */\n  readonly providers?: Provider[];\n\n  /**\n   * Defines the set of injectable providers that are visible to a Directive and its view DOM\n   * children only.\n   */\n  readonly viewProviders?: Provider[];\n\n  /**\n   * Registry of directives and components that may be found in this view.\n   *\n   * The property is either an array of `DirectiveDef`s or a function which returns the array of\n   * `DirectiveDef`s. The function is necessary to be able to support forward declarations.\n   */\n  directiveDefs: DirectiveDefListOrFactory|null;\n\n  /**\n   * Registry of pipes that may be found in this view.\n   *\n   * The property is either an array of `PipeDefs`s or a function which returns the array of\n   * `PipeDefs`s. The function is necessary to be able to support forward declarations.\n   */\n  pipeDefs: PipeDefListOrFactory|null;\n}\n\n/**\n * Runtime link information for Pipes.\n *\n * This is internal data structure used by the renderer to link\n * pipes into templates.\n *\n * NOTE: Always use `definePipe` function to create this object,\n * never create the object directly since the shape of this object\n * can change between versions.\n *\n * See: {@link definePipe}\n */\nexport interface PipeDef<T> {\n  /**\n   * Pipe name.\n   *\n   * Used to resolve pipe in templates.\n   */\n  name: string;\n\n  /**\n   * factory function used to create a new directive instance.\n   *\n   * NOTE: this property is short (1 char) because it is used in\n   * component templates which is sensitive to size.\n   */\n  n: () => T;\n\n  /**\n   * Whether or not the pipe is pure.\n   *\n   * Pure pipes result only depends on the pipe input and not on internal\n   * state of the pipe.\n   */\n  pure: boolean;\n\n  /* The following are lifecycle hooks for this pipe */\n  onDestroy: (() => void)|null;\n}\n\nexport type DirectiveDefFeature = <T>(directiveDef: DirectiveDef<T>) => void;\nexport type ComponentDefFeature = <T>(componentDef: ComponentDef<T>) => void;\n\n/**\n * Type used for directiveDefs on component definition.\n *\n * The function is necessary to be able to support forward declarations.\n */\nexport type DirectiveDefListOrFactory = (() => DirectiveDefList) | DirectiveDefList;\n\nexport type DirectiveDefList = (DirectiveDef<any>| ComponentDef<any>)[];\n\nexport type DirectiveTypesOrFactory = (() => DirectiveTypeList) | DirectiveTypeList;\n\nexport type DirectiveTypeList =\n    (DirectiveDef<any>| ComponentDef<any>|\n     Type<any>/* Type as workaround for: Microsoft/TypeScript/issues/4881 */)[];\n\n/**\n * Type used for PipeDefs on component definition.\n *\n * The function is necessary to be able to support forward declarations.\n */\nexport type PipeDefListOrFactory = (() => PipeDefList) | PipeDefList;\n\nexport type PipeDefList = PipeDef<any>[];\n\nexport type PipeTypesOrFactory = (() => DirectiveTypeList) | DirectiveTypeList;\n\nexport type PipeTypeList =\n    (PipeDef<any>| Type<any>/* Type as workaround for: Microsoft/TypeScript/issues/4881 */)[];\n\n\n// Note: This hack is necessary so we don't erroneously get a circular dependency\n// failure based on types.\nexport const unusedValueExportToPlacateAjd = 1;\n"]}